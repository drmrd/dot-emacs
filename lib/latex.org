#+TITLE: LaTeX Emacs Configuration
#+AUTHOR: DRMRD
#+PROPERTY: header-args    :tangle ~/.emacs.d/lib/latex.el :comments link :eval query :results output silent
#+OPTIONS: toc:nil num:nil ^:nil
#+STARTUP: indent

* latex.el Reference
** Determining the document structure at the current point
| Structure (@ Point) | Function                     |
|---------------------+------------------------------|
| Environment         | [[help:LaTeX-current-environment][LaTeX-current-environment]]    |
| Section             | [[help:LaTeX-current-section][LaTeX-current-section]]        |
| Indentation         | [[help:LaTeX-current-indentation][LaTeX-current-indentation]]    |
| Verbatim Macro      | [[help:LaTeX-current-verbatim-macro][LaTeX-current-verbatim-macro]] |
* Startup
** Load AucTeX and Preview LaTeX
AucTeX is the bread-and-butter LaTeX editor for Emacs and should
always be enabled to complement the built-in modes.

#+BEGIN_SRC emacs-lisp
  (sit-for 1)
  (message "Loading LaTeX configuration...")
  ; Don't try to load auctex.el. ELPA takes care of this
  ; (load "auctex.el" nil t t)
#+END_SRC
** Update Environment
AucTeX 11.88.9 and beyond check that TeX binaries exist in the =exec-path= (in
addition to the path), which is important for a number of pieces of AucTeX
functionality in addition to compilation functions (like =TeX-doc=). (Having it
in the system's =PATH= alone is not enough.) On OS X El Capitan and beyond, we
update this variable to pass this test (using the symbolic link to
=/Library/TeX/texbin= provided by MacTeX/TeXLive to avoid priviledge issues with
=/usr/local=).
#+SRC_NAME Add_texbin_to_exec-path_on_macOS
#+BEGIN_SRC emacs-lisp :tangle no
  (when (eq system-type 'darwin)
    (add-to-list 'exec-path "/Library/TeX/texbin" t))
#+END_SRC
** Load AucTeX
AucTeX is the bread-and-butter LaTeX editor for Emacs and should always be
enabled to complement the built-in modes.

#+SRC_NAME use-package_auctex
#+BEGIN_SRC emacs-lisp
    (use-package tex :ensure auctex
;      :init
;        (when (eq system-type 'darwin)
;          (add-to-list 'exec-path "/Library/TeX/texbin" t))
)
#+END_SRC
*** TODO Test whether the sit-for call is necessary
I no longer remember why I added that. Perhaps the problem has fixed
itself? Either way, this is why we document our config files,
children!
** AUCTeX Initialization/Configuration
*** Parse Document on Load and Save
#+BEGIN_SRC emacs-lisp
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
#+END_SRC

*** Multi-file Document Support
Make AUCTeX search for a master file instead of assuming it's the
current file.

#+BEGIN_SRC emacs-lisp
  (setq-default TeX-master nil)
#+END_SRC

** RefTeX Initialization/Configuration
*** Enable RefTeX in AUCTeX
First, we turn on RefTeX for AUCTeX http://www.gnu.org/s/auctex/manual/reftex/reftex_5.html
#+BEGIN_SRC emacs-lisp
  (add-hook 'TeX-mode-hook 'turn-on-reftex)
  (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
#+END_SRC
*** Add Custom Keybindings
#+BEGIN_SRC emacs-lisp
  (setq reftex-label-alist '((nil ?e nil "~\\eqref{%s}" nil nil)))
#+END_SRC
*** Set Default Bibliography
#+BEGIN_SRC emacs-lisp
  (setq reftex-default-bibliography
          '("~/workspace/citations/library.bib"))
#+END_SRC
** PreviewLaTeX
Preview LaTeX Mode allows you to preview the output of a LaTeX file in
a split-window environment. I currently don't enable it by default,
since I've been using Skim/external viewers instead.
#+BEGIN_SRC emacs-lisp :tangle no
  (load "preview-latex.el" nil t t)
#+END_SRC
* General Settings
** Ensure binaries are in =PATH= and =exec-path=
#+SRC_NAME latex_add-binaries
#+BEGIN_SRC emacs-lisp
  (setenv "PATH" (concat "/usr/texbin" ":"
                         "/usr/local/bin" ":"
                         (getenv "PATH")))
  (setq exec-path (append exec-path '("/usr/local/bin")))
#+END_SRC
** Enable "Advanced" Commands
As was the case in [[file:~/.emacs.d/init.org::*Enable%20"Advanced"%20Commands][my global settings]], I always enable some of the
non-beginner-friendly AucTeX commands that I use regularly.
#+SRC_NAME latex-mode_re-enable_advanced_commands
#+BEGIN_SRC emacs-lisp
  (put 'LaTeX-narrow-to-environment 'disabled nil)
#+END_SRC
* Editor Features
** Line Numbers
Display line numbers using [[help:nlinum-mode][=nlinum-mode=]].
#+SRC_NAME latex-mode-hook_add_nlinum-mode
#+BEGIN_SRC emacs-lisp
  (dolist (hook '(TeX-mode-hook LaTeX-mode-hook))
      (add-hook hook #'nlinum-mode))
#+END_SRC
** Code Folding
Enabling [[help:outline-minor-mode][=outline-minor-mode=]] allows us to fold sections/environments akin to
the way we do so in Org Mode.
*** Add outline-minor-mode to (La)TeX hooks
#+SRC_NAME enable_outline-minor-mode_in_TeX-mode_and_LaTeX-mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'TeX-mode-hook #'outline-minor-mode)
  (add-hook 'LaTeX-mode-hook #'outline-minor-mode)
#+END_SRC
*** Configure sane keybindings for outline-minor-mode
By default the prefix for outline-minor-mode is the insanely
inconvenient C-c @, so we change it to M-o instead. We also add
suffixes for just about every command we could ask for.
#+SRC_NAME outline-minor-mode_keymap_configuration
#+BEGIN_SRC emacs-lisp
  ; Outline-minor-mode key map
  (define-prefix-command 'cm-map nil "Outline-")
  ; HIDE
  (define-key cm-map "q" 'outline-hide-sublevels)    ; Hide everything but the top-level headings
  (define-key cm-map "\M-q" 'outline-hide-sublevels)
  (define-key cm-map "t" 'outline-hide-body)         ; Hide everything but headings (all body lines)
  (define-key cm-map "\M-t" 'outline-hide-body)
  (define-key cm-map "o" 'outline-hide-other)        ; Hide other branches
  (define-key cm-map "\M-o" 'outline-hide-other)
  (define-key cm-map "c" 'outline-hide-entry)        ; Hide this entry's body
  (define-key cm-map "\M-c" 'outline-hide-entry)
  (define-key cm-map "l" 'outline-hide-leaves)       ; Hide body lines in this entry and sub-entries
  (define-key cm-map "\M-l" 'outline-hide-leaves)
  (define-key cm-map "d" 'outline-hide-subtree)      ; Hide everything in this entry and sub-entries
  (define-key cm-map "\M-d" 'outline-hide-subtree)
  ; SHOW
  (define-key cm-map "a" 'outline-show-all)          ; Show (expand) everything
  (define-key cm-map "\M-a" 'outline-show-all)
  (define-key cm-map "e" 'outline-show-entry)        ; Show this heading's body
  (define-key cm-map "\M-e" 'outline-show-entry)
  (define-key cm-map "i" 'outline-show-children)     ; Show this heading's immediate child sub-headings
  (define-key cm-map "\M-i" 'outline-show-children)
  (define-key cm-map "k" 'outline-show-branches)     ; Show all sub-headings under this heading
  (define-key cm-map "\M-k" 'outline-show-branches)
  (define-key cm-map "s" 'outline-show-subtree)      ; Show (expand) everything in this heading & below
  (define-key cm-map "\M-s" 'outline-show-subtree)
  ; MOVE
  (define-key cm-map "u" 'outline-up-heading)                ; Up
  (define-key cm-map "\M-u" 'outline-up-heading)
  (define-key cm-map "n" 'outline-next-visible-heading)      ; Next
  (define-key cm-map "\M-n" 'outline-next-visible-heading)
  (define-key cm-map "p" 'outline-previous-visible-heading)  ; Previous
  (define-key cm-map "\M-p" 'outline-previous-visible-heading)
  (define-key cm-map "f" 'outline-forward-same-level)        ; Forward - same level
  (define-key cm-map "\M-f" 'outline-forward-same-level)
  (define-key cm-map "b" 'outline-backward-same-level)       ; Backward - same level
  (define-key cm-map "\M-b" 'outline-backward-same-level)
  (global-set-key "\M-o" cm-map)
#+END_SRC
**** TODO Move to init.org
*** Load outline-magic and bind outline-cycle to C-tab
This allows for org-like cycling of folded regions. Note the =:after=
keyword in the use-package call ensures that outline-magic is only
loaded after outline. This is the (MUCH) cleaner version of the old
=(eval-after-load 'outline '(progn [code for loading outline-magic]))=
construct!
#+BEGIN_SRC emacs-lisp
  (use-package outline-magic
      :after outline
      :bind ("C-<tab>" . outline-cycle))
#+END_SRC

*** Adding extra outline headings
In [[http://emacs.stackexchange.com/a/3076/8643][a brilliant answer]] on Emacs.SE, a most-excellently-named user
described some of his configuration. In particular, for adding fake
sections to his documents (i.e., headings that indicate to auctex
(and, hence, outline-minor-mode) the start of something section-like,
but things that are not compiled by LaTeX (comments)), and I'm dead
set on trying this out. Frankly, I can't believe I hadn't thought of
this myself!
#+BEGIN_SRC emacs-lisp
  ;; extra outline headers
  (setq TeX-outline-extra
        '(("^\\s-*%chapter" 1)
          ("^\\s-*%section" 2)
          ("^\\s-*%subsection" 3)
          ("^\\s-*%subsubsection" 4)
          ("^\\s-*%paragraph" 5)
          ("^\\s-*%proof" 5)))

  ;; add font locking to the headers
  (font-lock-add-keywords
   'latex-mode
   '(("^%\\(chapter\\|\\(sub\\|subsub\\)?section\\|paragraph\\|proof\\)"
      0 'font-lock-keyword-face t)
     ("^\\s-*%chapter{\\(.*\\)}"       1 'font-latex-sectioning-1-face t)
     ("^\\s-*%section{\\(.*\\)}"       1 'font-latex-sectioning-2-face t)
     ("^\\s-*%subsection{\\(.*\\)}"    1 'font-latex-sectioning-3-face t)
     ("^\\s-*%subsubsection{\\(.*\\)}" 1 'font-latex-sectioning-4-face t)
     ("^\\s-*%paragraph{\\(.*\\)}"     1 'font-latex-sectioning-5-face t)
     ("^\\s-*%proof{\\(.*\\)}"         1 'font-latex-sectioning-5-face t)))
#+END_SRC
**** TODO Consider expanding on this
For instance, we could add support for TODO comments that appear like
the ones in Org.
** Soft Line Wrapping
*** Navigate soft-wrapped lines visually
=visual-line-mode= is a WYSIWYG mode for Emacs's navigation keybindings, which
binds keys like =C-f=, =C-e=, and =C-k= to new commands that respect
soft-wrapping (and, hence, the visually-displayed line instead of the logical
line you are on in the current file).

#+SRC_NAME enable_visual-line-mode_in_TeX-mode_and_LaTeX-mode
#+BEGIN_SRC emacs-lisp
  (dolist (hook '(TeX-mode-hook LaTeX-mode-hook))
    (add-hook hook #'visual-line-mode))
#+END_SRC

*** Continue indentation level on soft-wrapped lines
By default Emacs does not preserve indentation on softly-wrapped lines. For
instance, suppose you had the following text in a buffer:

#+NAME: soft-wrapping_indentation_example__no_wrapping_whatsoever
#+BEGIN_EXAMPLE
  This is a paragraph talking about something. As the paragraph continues, it becomes clear that we should provide an example of what we're talking about to the dear reader. Our imaginary markup language visually emphasizes indented blocks differently than their unindented counterparts, so we provide the example as follows:

      This is our example. It is longer than sixty characters in length, and then some. In fact, it is longer than twice that length, if I am not mistaken. And I rarely am about line lengths, since I have a convenient column indicator in my mode line. In fact, goodness me, we're far past twice sixty, steadily encroaching on six times that length!

  Following this example, we continue our discussion here in another paragraph. It's just as relevant as the previous one. If you're still reading what might as well be lorem ipsum at this point, kudos.
#+END_EXAMPLE

In a window that is only sixty characters in width, this text will be
soft-wrapped as follows by default:

#+NAME: soft-wrapping_indentation_example__no_adaptive-wrap-prefix-mode
#+BEGIN_EXAMPLE
  This is a paragraph talking about something. As the
  paragraph continues, it becomes clear that we should provide
  an example of what we're talking about to the dear
  reader. Our imaginary markup language visually emphasizes
  indented blocks differently than their unindented
  counterparts, so we provide the example as follows:

      This is our example. It is longer than sixty characters
  in length, and then some. In fact, it is longer than twice
  that length, if I am not mistaken. And I rarely am about
  line lengths, since I have a convenient column indicator in
  my mode line. In fact, goodness me, we're far past twice
  sixty, steadily encroaching on six times that length!

  Following this example, we continue our discussion here in
  another paragraph. It's just as relevant as the previous
  one. If you're still reading what might as well be lorem
  ipsum at this point, kudos.
#+END_EXAMPLE

As you can see, the built-in soft-wrapping in Emacs at best leaves much to be
desired in terms of preserving the syntactic meaning of a buffer's context. In
fact it has already potentially introduced syntactic ambiguity: is the second
paragraph in the soft-wrapped text an indented paragraph or a soft-wrapped,
indented example?

Compare this to the output of =fill-region= (or an equivalent auto-filling,
hard-wrapping command) operating on the original buffer:

#+BEGIN_EXAMPLE
  This is a paragraph talking about something. As the
  paragraph continues, it becomes clear that we should provide
  an example of what we're talking about to the dear
  reader. Our imaginary markup language visually emphasizes
  indented blocks differently than their unindented
  counterparts, so we provide the example as follows:

      This is our example. It is longer than sixty characters
      in length, and then some. In fact, it is longer than
      twice that length, if I am not mistaken. And I rarely am
      about line lengths, since I have a convenient column
      indicator in my mode line. In fact, goodness me, we're
      far past twice sixty, steadily encroaching on six times
      that length!

  Following this example, we continue our discussion here in
  another paragraph. It's just as relevant as the previous
  one. If you're still reading what might as well be lorem
  ipsum at this point, kudos.
#+END_EXAMPLE

Here the indented example syntax remains clear but only at the potential cost of
losing semantic meaning. Imagine, for instance, that we'd placed each sentence
in our example text onto its own line originally. This is not so far-fetched,
since it's what I do when writing in version-controlled LaTeX files. It has the
advantage of allowing parsers to easily perform sentence-level transformations
to text and also can prove invaluable when =diff=ing the changes between two
versions of a paper. Hard-wrapping a region in a buffer obliterates this
semantic information (/i.e./, the demarcation of the beginning and end of each
sentence).

This is just one of the many semantically-destructive aspects of hard-wrapping
lines in text (prose or otherwise) that compel me to prefer efficient
indentation-manipulating commands coupled with smart soft-wrapping over the
convenience of =auto-fill-mode=. So far, by "smart" I mean "capable of
preserving indentation on soft-wrapped lines and respecting the =fill-column=.
We enable [[help:adaptive-wrap-prefix-mode][=adaptive-wrap-prefix-mode=]] to achieve the former.

#+SRC_NAME adaptive-wrap-prefix-mode_use-package
#+BEGIN_SRC emacs-lisp
  (use-package adaptive-wrap :ensure t
    :init (add-hook 'visual-line-mode-hook 'adaptive-wrap-prefix-mode))
#+END_SRC

Likewise, we enable =visual-fill-column-mode= whenever =visual-line-mode= is
active to soft-wrap buffers at the current =fill-column=. See [[http://melpa.org/#/visual-fill-column][here]] for
=visual-fill-column-mode='s MELPA documentation page. It's a small minor mode
that does this one thing and this one thing quite well. More conventional
implementations of soft line wrapping at a fixed column could be somewhat
buggy.

#+SRC_NAME visual-fill-column_use-package
#+BEGIN_SRC emacs-lisp
  (use-package visual-fill-column :ensure t
    :init (global-visual-fill-column-mode))
#+END_SRC

** LaTeX Math Mode
Load [[help:LaTeX-math-mode][LaTeX Math Mode]] by default. This is usually bound to 'C-c ~' (and
can still be toggled using that keybinding, but it's useful enough to
enable it outright).

#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
#+END_SRC

With this mode activated, pressing ` followed by a symbol will execute
a specific command as defined in the [[help:LaTeX-math-list][LaTeX-math-list]] alist (or one of
the built-in expansions. As explained in the documentation each
element of LaTeX-math-list is a list of the form
(KEY VALUE [opt: MENU CHARACTER]) for
 * KEY: a key such that `KEY will be replaced by VALUE
   - Can be nil, if you just want the VALUE to appear in the specified
     menu(s) but not bound to some `KEY
 * VALUE: the desired replacement string or a function to be called(!)
 * MENU: a string (e.g., "Greek"), list of strings (e.g., ("AMS"
   "Delimiters")), or nil, specifying which menu(s) this key/value
   should appear in. No menu items are created if this is nil.
 * CHARACTER: A unicode character to be displayed in the menu (can be
   nil if none is desired/applicable).
Note that this works with [[info:emacs#Init%20Syntax][all characters]], including "shifted"
characters like '?\C-a' or '?\M-b', if you use the correct syntax.
#+BEGIN_SRC emacs-lisp tangle: no
    (setq LaTeX-math-list '((?c "cong ")))
#+END_SRC
** Projectile Mode
Load =projectile= for project management.
#+BEGIN_SRC emacs-lisp
  (add-hook 'TeX-mode-hook #'projectile-mode)
  (add-hook 'LaTeX-mode-hook #'projectile-mode)
#+END_SRC
** ispell Mode
Note that the =ispell-tex-arg-end= function I mention below is defined
in =ispell.el= as follows.
#+BEGIN_SRC emacs-list :tangle no
  (defun ispell-tex-arg-end (&optional arg)
    "Skip across ARG number of braces."
    (condition-case nil
        (progn
          (while (looking-at "[ \t\n]*\\[") (forward-sexp))
          (forward-sexp (or arg 1)))
      (error
       (message "Error skipping s-expressions at point %d." (point))
       (beep)
       (sit-for 2))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;;; Per the documentation, `ispell-tex-skip-alists' is a list of two
  ;;; alists, each of these themselves being lists of 2- and 3-
  ;;; tuples. The tuples are all of the form
  ;;;     (BEGINREGEX ENDFUNCTION &optional BRACESCOUNT)
  ;;; where `BEGINREGEX' (the "key" referred to in this variable's
  ;;; documentation) is the regular expression (as a string) to match at
  ;;; the beginning of the region we want ispell to skip over,
  ;;; `ENDFUNCTION' is a function that moves the point forward to the
  ;;; end of the region we wish to skip. The optional argument
  ;;; `BRACESCOUNT' is a numeric argument passed to `ENDFUNCTION',
  ;;; which, for the built-in `ENDFUNCTION' (always
  ;;; `ispell-tex-arg-end') states the number of sexps to skip,
  ;;; defaulting to 1. The `ispell-tex-arg-end' function normally just
  ;;; moves past all optional arguments in the tex command, skips
  ;;; max(1,`BRACESCOUNT') matched sets of {}'s, and returns, catching
  ;;; any errors along the way. AFAICT, specifying a different value of
  ;;; `ENDFUNCTION' should just handle finding the end of the region to
  ;;; skip in a different manner without any side effects. That said,
  ;;; use at your own risk, since the source's documentation is pretty
  ;;; terrible.
  ;;;
  ;;; Actually, it looks like BOTH `BEGINREGEX' and `ENDFUNCTION' can be
  ;;; regular expressions (given as strings) and/or functions!  The
  ;;; result of each should be to move the mark to wherever you damn
  ;;; well please.
  ;;;
  ;;; The difference between the first and second entries in
  ;;; `ispell-tex-skip-alists' is that each `BEGINREGEX' inside the
  ;;; second list is matched from within a \begin{...} environment
  ;;; delimiter.  Haven't looked into how this affects the behavior of
  ;;; `ENDFUNCTION', but from the source of `ispell-tex-arg-end', the
  ;;; regexs used for `ENDFUNCTION' in the default value of
  ;;; `ispell-tex-skip-alists', and a brief read through function that
  ;;; loads the latter in `ispell.el', my guess is that `ENDFUNCTION'
  ;;; behavior is totally unaffected. (So you should look for an end
  ;;; block if you want to skip the entirety of an environment, not,
  ;;; e.g., just the environment name.)
  ;;;
  ;;; Note: `ispell-tex-arg-end' passes (or `BRACESCOUNT' 1) to
  ;;; `forward-sexp', so specifying `BRACESCOUNT' to 0 does have the
  ;;; expected effect of *only* skipping optional arguments. This is
  ;;; useful, for instance, when wanting to skip the arguments of a
  ;;; table environment (where there are never things to spellcheck),
  ;;; but you don't want to skip the table's contents.
  (setq ispell-tex-skip-alists
        (list (append (car ispell-tex-skip-alists)
                      '(("\\\\def\\\\" . ispell-tex-arg-end)))
              ;; Feel free to append to the 2nd alist, too. I've no use
              ;; for it at the moment, so it's just going back as is. Of
              ;; course, this means this whole command is rather
              ;; unnecessarily verbose for the time being. But hey, it's
              ;; readable and ready for extension.
              (cdr ispell-tex-skip-alists)))
#+END_SRC
** Save Place Mode                  :save_place_mode:Persistence:Navigation:
When opening a file, Save Place Mode restores the point to the last place it
appeared in a buffer containing the file. For each tracked file, point locations
are stored in the =save-place-file=, which defaults to =.emacs.d/places= for
Emacs versions 25.1+. While =save-place-mode= is global, storing file positions
for every file you open in Emacs, you can be more selective with when this
occurs by turning on =save-place-local-mode= instead on a per file or major mode
basis.  #+SRC_NAME latex_hook_to_save-place-local-mode
#+BEGIN_SRC emacs-lisp
  (dolist (hook '(TeX-mode-hook LaTeX-mode-hook))
    (add-hook hook #'save-place-local-mode))
#+END_SRC
* Appearance
** Custom Syntax Highlighting
Syntax highlighting is controlled by Font Lock Mode, and it is a simple matter
to add additional keywords for it to recognize and color accordingly using the
[[help:font-lock-add-keywords][font-lock-add-keywords]] function. Keywords are passed to this function as a list
of elements of the form described [[help:font-lock-keywords][here]].

AucTeX, however, provides its own LaTeX-tailored keyword configuration variable
called [[help:font-latex-user-keyword-classes][font-latex-user-keyword-classes]]. It consists of a list of "keyword
classes", each of the form
#+SRC_NAME font-latex-user-keyword-classes_keyword_class_syntax
#+BEGIN_EXAMPLE emacs-lisp
  (<class> ((<keyword> <args>) ...) <face> <type>)
#+END_EXAMPLE
where =<class>=, =<keyword>=, and =<args>= are strings and both =face= and
=type= are (unquoted) symbols. (The pair =(<keyword> <args>)= can also just be a
simple string =<keyword>= if you don't care about highlighting arguments/the
macro takes no arguments/you like the default argument highlighting behavior.)
The =font-latex= package then handles setting up font-lock matchers for each
keyword in the class, including for its arguments thanks to its 'argument
string' (specified by =<arg>= above).

The example provided in the [[help:font-latex-user-keyword-classes][help page]] of an argument string for =\newcommand=
conveys the idea well. The correct entry in a keyword class for =\newcommand=
would look like =("newcommand" "*|{\[[{")=, where, character-by-character, the
string ="*|{\[[{"= indicates that
  - * :: =\newcommand= can be starred
  - | :: the next two characters form a pair of alternative arguments (/i.e./,
         either ={= or =\= will be the next argument).
  - { :: a mandatory argument (wrapped in ={= and =}=)
  - \ :: a mandatory argument that is a macro and not wrapped in braces
  - [ :: an optional argument
  - [ :: another optional argument
  - { :: a mandatory argument
Note the "Polish-style" use of =|= as a /prefix/ to the alternatives ={= and
=\=. I missed this when first reading the documentation.

#+NAME setup_font-latex-user-keyword-classes
#+BEGIN_SRC emacs-lisp
  (setq font-latex-user-keyword-classes
        '(("idxdefs"  (("idxdef" "[{")
                       ("NewIndexableMathObject" "{{{{{{")) bold command)))
#+END_SRC
* TODO Improving Help Commands
Wouldn't it be amazing if there was a =describe-latex-macro= command
for Emacs with the same functionality as =describe-function=? This is
a cool idea for a project that we should totally start working on.
* Customizing Environment Templates/Insertion Behavior
** Inserting Items with Alt + Ret                           :enumerate:item:
Within enumerate-like environments (in fact, at any point in a LaTeX
buffer), hitting [Alt] + [Return] invokes [[help:LaTeX-insert-item][LaTeX-insert-item]]
* Support for Custom Macros & Environments
** Make AUCTeX Aware of Custom Theorem Environments
#+SRC_NAME auctex_add_custom_environments
#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook
    (lambda ()
      (LaTeX-add-environments
        '("claim"      LaTeX-env-label)
        '("conjecture" LaTeX-env-label)
        '("convention" LaTeX-env-label)
        '("cor"        LaTeX-env-label)
        '("example"    LaTeX-env-label)
        '("lem"        LaTeX-env-label)
        '("note"       LaTeX-env-label)
        '("notation"   LaTeX-env-label)
        '("proof"      LaTeX-env-label)
        '("prop"       LaTeX-env-label)
        '("question"   LaTeX-env-label)
        '("rem"        LaTeX-env-label)
        '("thm"        LaTeX-env-label))))
#+END_SRC
** Make RefTeX aware of idxdef and indexdef indexing commands
Make RefTeX aware of our custom indexing commands and bind some of them to
keys. We also set =\indexed= to be the default indexing command in RefTeX, which
is bound to =C-c /=.
#+SRC_NAME set_reftex-index-macros
#+BEGIN_SRC emacs-lisp
  (add-hook 'reftex-mode-hook
            (lambda ()
              (setq reftex-index-macros
                    '(("\\indexed{*}" "idx" ?x "" nil nil)
                      ("\\idxdef{*}" "idx" ?d "" nil nil)
                      ("\\indexdef{*}" "idx" ?D "" nil nil)))
              (setq reftex-index-default-macro '(?x "idx"))))
#+END_SRC
*** TODO Create a RefTeX mode hydra, possibly bound to =C-c r=
There are so many amazing RefTeX mode commands I forget about that it's probably
worth collecting them somewhere.
#+END_SRC
* Custom Functions
** TODO Forward/Backward Token/Mode/Environment Boundary Functions
By default, the key combinations 'C-M-f' and 'C-M-b' are bound to
[[help:forward-sexp][forward-sexp]] and [[help:backward-sexp][backward-sexp]], which aren't very useful in a TeX
document. We will instead bind these commands to functions that look
for the next/previous instance of a token delimiter: *{*; a math-mode
delimiter: *$*, *$$*, *\[$, or *\]$; or an environment *begin* or
*end* statement. We collectively call such things *LaTeX boundary
delimiters*, although reserve the right to change this name later.

#+SRC_NAME TeX-BoundaryDelimiters
#+BEGIN_SRC emacs-lisp :tangle no
  (defvar drmrd-init/lib/latex-TokenDelimiters
    '(("{" . nil)
      ("}" . nil))
    "An alist consisting of elements (CAR . CDR), in which CAR is
    always a string representing a (Whatever)Tex token
    delimiter. So, for instance, the default alist in a TeX or
    LaTeX distribution would include a string for matching '{' and
    another for matching '}'. In each list element, if CDR is
    non-nil treat CAR as a regular expression string and otherwise
    treat it like a string to be matched literally.")

  (defvar drmrd-init/lib/latex-MathDelimiters
    '(("$$" . nil)
      ("$" . nil)
      ("\\[" . nil)
      ("\\]" . nil))
    "An alist consisting of elements (CAR . CDR), in which CAR is
    always a string representing a (Whatever)Tex math mode
    delimiter (which is to say either an inline or displayed
    equation). So, for instance, the default alist in a TeX or
    LaTeX distribution would include strings for matching '$',
    '$$', '\[', and '\]'. In each list element, if CDR is non-nil
    treat CAR as a regular expression string and otherwise treat it
    like a string to be matched literally.")

  (defvar drmrd-init/lib/latex-EnvDelimiters
    '(("\\begin{\w+}" . t) ("\\end{\w+}" . t))
    "An alist consisting of pairs of elements (CAR . CDR), in which CAR
    is always a string representing a (Whatever)Tex environment
    beginning or ending delimiter (which is to say either an inline or
    displayed equation). So, for instance, the default alist in a LaTeX
    distribution would include strings for matching '\begin{<valid
    env-name>}' and '\end{<valid env-name>}'. In each list element, if
    CDR is non-nil treat CAR as a regular expression string and
    otherwise treat it like a string to be matched literally.")

  (defvar drmrd-init/lib/latex-BoundaryDelimiter
    (append drmrd-init/lib/latex-TokenDelimiters
            drmrd-init/lib/latex-MathDelimiters
            drmrd-init/lib/latex-EnvDelimiters)
    "The complete alist of 'LaTeX Boundary Delimiters' (delimiters
    of tokens, math modes, and environments) used, e.g., in
    conjunction with the `forward-LaTeX-boundary-delimiter'
    function. In each element (CAR . CDR), CAR is always a string
    representing a LaTeX boundary delimiter either as a string
    literal or an elisp regular expression string, with a non-nil
    CDR indicating that it is the latter.")


  (defun forward-LaTeX-boundary-delimiter (&optional arg)
    "Move forward to the next instance of a delimiter of a TeX
  token, math mode, or environment. With ARG, do it that many
  times.  Negative arg -N means find the N-th instance of such a
  delimiter in the backwards direction.  The definition of a LaTeX
  boundary delimiter may be configured by modifying the
  `drmrd-init/lib/latex-BoundaryDelimiter' variable."
    (interactive "^p") ; Recall that "^" makes this compatible with
                       ; shift selection and "p" converts the prefix
                       ; argument to a number if present.
    (or arg (setq arg 1)) ; Set `arg` equal to 1 if not provided.
    (goto-char (or (scan-latex-boundary-delimiters (point) arg) (buffer-end arg)))
    (if (< arg 0) (backward-prefix-chars)))

  (defun scan-latex-boundary-delimiters (from count)
    "Scan from character number FROM forward or backward depending
  on the sign of COUNT. Scan until |COUNT|
  LaTeX-boundary-delimiters have been found and return the
  character number of the |COUNT|-th delimiter. Returns nil if the
  beginning or end of (the accessible part of) the buffer is
  reached before |COUNT|-many matches are found."
    (sleep-for 1))
#+END_SRC


*** TODO Decide on a name for these functions
* Indentation
** Set default indentation level to 4 spaces
#+BEGIN_SRC emacs-lisp
  (setq-default LaTeX-default-offset 4)
#+END_SRC
** Customize general indentation settings
#+BEGIN_SRC emacs-lisp
  ;;
  ;; Customizing general indentation settings
  ;;
  ; Set indentation of current line by 4n where n is the sum of the
  ; number of unmatched instances of "\begin{<environment>}" and "{":
  (setq-default LaTeX-indent-level 4)
  (setq-default TeX-brace-indent-level 4)
  ; Add 0m to indentation level of current line where m is the number
  ; currently-unmatched, enumerate-like environments at our current
  ; location (and the cursor is on a line beginning with "\item" or
  ; something "\item-like":
  (setq-default LaTeX-item-indent 0)
#+END_SRC
** Advise indent command to indent inside parts, chapters, sections, etc.
#+BEGIN_SRC emacs-lisp
  (defadvice LaTeX-indent-line (after LaTeX-indent-line-in-sections-advice activate)
    "A function designed to advise the indent command to indent within
     parts, chapters, sections, subsections, etc."
    (interactive)
    (let (
           (section-list ; Make a copy of LaTeX-section-headers
             (copy-list LaTeX-section-list)
           )
           (prevline ; Set equal to the previous line as a string
             (save-excursion
               (forward-line -1)
               (thing-at-point 'line t)
             )
           )
         )
         ; If the previous line is the start of a section, indent
         ; the current line by an additional LaTeX-default-offset
         ; spaces.
         ;
         ; The while loop essentially uses section-list, a copy of
         ; LaTeX-section-list, as a stack, pushing another section
         ; name off the stack with each iteration until it is empty.
         ;
         ; The entire while loop is wrapped in a save-excursion call
         ; to avoid moving the pointer around. I'm not sure if this
         ; is less efficient than just putting it in the conditional
         ; or if it matters at all. Perhaps something to look into
         ; another time.
         (save-excursion
           (while section-list
             (if (string-match (concat "\s-+\\" (caar section-list) ".*\s-") prevline)
               (progn
                 ; Move to first non-whitespace character in line
                 (back-to-indentation)
                 ; Insert LaTeX-default-offset many spaces
                 (indent-to 0 LaTeX-default-offset)
                 (setq section-list nil)
               )
             )
             (setq section-list (cdr section-list))
           )
         )
    )
  )
#+END_SRC
*** DONE Fix the interaction between this and environment insertion commands
CLOSED: [2015-12-05 Sat 14:27]
It seems that this advice may break environment insertion via C-c
C-e. The latter now places the "\end{...}" block immediately before
the "\begin{...}" one.
*** I've officially learned a trick or two!
Figuring out the "right" way to implement this in Emacs was daunting a
few months ago. Today (<2015-12-02 Wed>) I did it in 1.5 hours.
* Debugging
** Change TeX debugging mode (for more informative error messages)
#+BEGIN_SRC emacs-lisp
  (setq LaTeX-command-style '(("" "%(PDF)%(latex) -file-line-error %S%(PDFout)")))
#+END_SRC
* Compilation & External Programs
** Compile PDFs by Default
#+BEGIN_SRC emacs-lisp
  (setq TeX-PDF-mode t)
#+END_SRC
** Create Custom Compilation Commands (& Tweak Built-In Ones)
#+BEGIN_SRC emacs-lisp
    (defun drmrd/latex/string=-cars (cons1 cons2)
      "Determine if two cons are equal by comparing their cars as
      strings. The car comparison is done using `string='. No
      type-checking is performed before attempting to compare cons, so
      this can lead to unexpected outcomes if CONS1 and CONS2 are not
      lists (or if their cars are not strings)."
      (string= (car cons1) (car cons2)))
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook
    (lambda ()
      (add-to-list 'TeX-command-list
                   '("latexmk" "latexmk -outdir=./tmp %t -pdf %s"
                     TeX-run-TeX nil t :help "Run latexmk on file")
                   nil 'drmrd/latex/string=-cars)))
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook
    (lambda ()
      (add-to-list 'TeX-command-list
                   '("LaTeX+" "latexmk -auxdir=./tmp %t -pdf %s"
                     TeX-run-TeX nil t :help
                     "Run latexmk, storing temporary files in ./tmp")
                     nil 'drmrd/latex/string=-cars)))
#+END_SRC
** Enable support for latexmk via C-c C-c
#+BEGIN_SRC emacs-lisp

  ;(add-hook 'TeX-mode-hook '(lambda () (setq TeX-command-default "latexmk")))
#+END_SRC
** Set how TeX handles DVI files
#+BEGIN_SRC emacs-lisp
  (setq tex-dvi-print-command "dvips")
  (setq tex-dvi-view-command "xdvi")
#+END_SRC
** TODO Store temporary files in ./tmp
** Configure view programs                     :Viewing:Output:Evince:Okular:
This code could equally well be customized, since it's rather volatile or at
very least system dependent. The current version of this configuration is taken
from [[http://tex.stackexchange.com/a/150645][this TeX.SE answer]].
#+SRC_NAME auctex_set_TeX-view-program-list
#+BEGIN_SRC emacs-lisp
  ;; See [[help:TeX-expand-list-builtin][TeX-expand-list-builtin]] and
  ;; [[help:TeX-expand-list][TeX-expand-list]] for a complete list of the "%foo"
  ;; expansions appearing in the shell commands below.
  (eval-after-load "tex"
    (lambda ()
      (cl-case system-type

        ('gnu/linux
         (setq TeX-view-program-list      '(("Evince" "evince --page-index=%(outpage) %o")))
         (setq TeX-view-program-selection '((output-pdf "Evince"))))

        ('darwin
         ;; Use Skim as default PDF viewer
         ;; Skim's displayline is used for forward search (from .tex to .pdf)
         ;; Its -b option highlights the current line; option -g opens Skim in the
         ;; background
         (setq TeX-view-program-list
               '(("Skim" "/Applications/Skim.app/Contents/SharedSupport/displayline -b -g %n %o %b")
                 ("Preview" "open -a Preview.app %n")))
         (setq TeX-view-program-selection '((output-pdf "Skim")))))))

#+END_SRC
* Wrap Up
There is nothing to do here for the time being, but we'll at least
record that we've loaded the file successfully in the *Messages* buffer.
#+BEGIN_SRC emacs-lisp
  (message "Finished loading LaTeX configuration!")
#+END_SRC
