#+TITLE: drmrd's Emacs Init File
#+AUTHOR: drmrd
#+OPTIONS: toc:nil num:nil ^:nil
#+PROPERTY: header-args :comments link :eval query :results output silent :tangle yes
#+STARTUP: indent

* General Information/Notes
** What should go into main.org?
The main.org file is loaded at startup, rather than on demand. Hence
it should contain any and all Emacs settings that you'd like loaded
every session. Accordingly, good examples of what code this file
should contain are

- Loading packages that are used in all major modes
- Emacs customizations that affect the editor's UI
- All global settings. These include globally-defined keybindings,
  the default major mode for new files, etc.
- Global theme customizations

** Emacs Configuration Files Hierarchy
At present, main.org loads files written by me from _one_ place:
*** ~/.emacs.d/lib
The new folder for storing .org files, intended to contain libraries
meant for customizing, e.g., specific major modes (in ways that go
beyond the scope of this file). For instance, the file [[~/workspace/elisp/emacs_latex.el][emacs_latex.el]]
from the folder ~/workspace/elisp is being converted into a human
readable .org file [[~/.emacs.d/lib/latex.org][latex.org]] in this new directory.

main.org loads all .org files in this directory by default, unless
told to do otherwise.

This is also the location best suited for large functions or
collections thereof whose contents is appropriate for main.org but
would add hundreds or thousands of lines of code unnecessarily.

**** TODO List all libraries of the latter type here
**** TODO List any libraries in ~/.emacs.d/lib/ not loaded by default here.

**** Rules for creating new libraries in .emacs.d/lib/
***** For Customizing a Major Mode:
- Add a new bullet in the [[*Major%20Mode%20Customization][Major Mode Customization]] section below
  containing the name of the mode or (for multiple, related modes) the
  relevant environment name (e.g. [[*LaTeX%20Modes][LaTeX Modes]] is used below when
  loading libraries for all TeX-related packages.)
- There should be a single configuration file for each bullet in [[*Major%20Mode%20Customization][Major
  Mode Customization]], typically of the form bullet_title.org. That
  file should then load any relevant packages.
****** What To Do When a Major Mode Configuration Library Gets Too Big
- Keep the bullet_title.org file
- Create a ~/.emacs.d/lib/bullet_title subdirectory
- Add libraries to this subdirectory and load them from
  bullet_title.org
*** ~/elisp
This is the location in which all third party scripts should be
placed. They should NOT be placed here manually, however. Instead, add
an entry for each new script into the makefile in that directory, then
install them from the command line as byte-compiled elisp files.
*** ~/workspace/elisp [[*NOTE:%20This%20folder%20should%20be%20considered%20OBSOLETE.][(OBSOLETE)]]
This is the old location for storing .el files. It should be replaced
by literate programming .org files in the folder ~/.emacs.d/lib/

main.org loads all .el files in this directory, unless told to do
otherwise.

**** DONE List any exceptions to this loading rule here.
This is considered done, since the folder is obsolete.
**** DONE NOTE: This folder should be considered OBSOLETE.
CLOSED: [2015-12-02 Wed 15:54]
No new elisp libraries should be added here. Due to some undesirable
effects of the code in these old .el files, the original directory has
been renamed elisp.bak. Any configuration files/settings needed that
are in elisp.bak should be integrated into org files in the .emacs.d
directory.

(This was really completed much earlier than the close date/time.)
*** ~/.emacs.d/
Adding libraries to the root .emacs.d directory should ONLY happen if
they implement/customize features affecting all major modes by default
AND contain too much code for this file.

A good use case for such a file is indentation.org, which contains
settings for all global tweaks to how indentation and filling are done
in Emacs.

Eventually, it may very well be that I stop doing this entirely,
loading these configuration files from, e.g., a .emacs.d/lib/global
subdirectory, to help avoid namespace collisions with third party
packages.
** Notes on Aquamacs Configuration Oddities
Since Aquamacs is obnoxious, my .emacs and .emacs.d files were
originally found in

    ~/Library/Preferences/Aquamacs Emacs/Preferences.el

and

    ~/Library/Preferences/Aquamacs Emacs/

respectively. Now that I'm using this Literate Emacs Init file,
there's no need to store them there, and Preferences.el simply loads
org-babel and points it here.

When opened Aquamacs loads elisp code contained in the following files:

    ~/.emacs
    ~/Library/Preferences/Aquamacs Emacs/Preferences.el
    ~/Library/Preferences/Aquamacs Emacs/customizations.el

where the last file is automatically written when you "Save Options"
in an Aquamacs menu. The advantage to using the god-awfully-located
Preferences.el file is that it overrides automatically-generated
customizations like code in .emacs should but doesn't.

Aquamacs will also find libraries contained in

    ~/Library/Preferences/Aquamacs Emacs/Preferences.el

which is why I originally moved mine there from "~/.emacs.d".
** FAQ
*** Q: How can I interactively evaluate lisp statements?         :QUESTION:
**** A: Call =ielm= (*Inferior Emacs Lisp Mode*)
=ielm= (Inferior Emacs Lisp Mode) is essentially an elisp shell
environment, used exactly for this purpose. It's way, WAY easier than,
e.g., writing and evaluating statements in =*Scratch*=. When you run
=ielm= (which is done with the command =M-x ielm=) a new =*ielm*=
buffer is created that serves as the elisp shell.

This is great for evaluating code as you go and designing new
functions.
*** Q: How can I access a complete list of variables defined by a package? :QUESTION:
**** A: The easy (if not completely reliable) way
Use =describe-variable= via "C-h v", type the name of the package (or
part of it) in the minibuffer, and then tab twice to get an
autocompletion list. Since a typical package will begin its variable
names with its own name, this generates a reasonably complete list.
** Elisp Notes and Techniques
*** Q: What's an alist?
**** A: An association list
An alist is a list =mylist= of cons cells =(car . cdr)= (in dotted
pair notation) and atoms. For example:

#+BEGIN_EXAMPLE emacs-lisp
  (setq mylist
    '((setting1 . value1)
     (setting2 . value2)
     (setting3 . value3)))
#+END_EXAMPLE

sets =mylist= equal to an alist. In each cons cell =(setting
. value)=, the CAR =setting= is called a *key* and the CDR =value= a
*value*. A key (or value) corresponding to a value (or key) is called
an *association* for the key (or value) in =mylist=.

The following functions are commonly used to retrieve data from
alists.

| Function                     | Description                   | Example                          |
|------------------------------+-------------------------------+----------------------------------|
| (assoc key alist)            | Returns the first association | (assoc 'setting1 mylist)         |
|                              | to =key= in =alist=           | returns value1                   |
| (rassoc value alist)         | Returns the first association | (assoc 'value1 mylist)           |
|                              | to =value= in =alist=         | returns setting1                 |
| (assq key alist)             | Like =assoc= but uses =eq=    |                                  |
|                              | for comparison instead        |                                  |
|                              | of =equal= which is faster    |                                  |
|                              | (but useless when things      |                                  |
|                              | other than symbols appear as  |                                  |
|                              | keys in the alist)            |                                  |
| (rassq key alist)            | Like =rassoc= but uses =eq=   |                                  |
|                              | for comparison, just like the |                                  |
|                              | last function                 |                                  |
| (assoc-default key alist     | TODO: Fill this in            |                                  |
| &optional test default)      |                               |                                  |
| (copy-alist alist)           | Returns a two-level deep copy |                                  |
|                              | of the given alist            |                                  |
| (assq-delete-all key alist)  | Delete every element from the | (setq mylist '((a 1) (b 1) (a 2) |
|                              | alist with a CAR matching the | (b 3) (b 4) (b 5) (a 3) (c 2)))  |
|                              | given key, and return the new | (assq-delete-all 'a mylist)      |
|                              | list. This                    | returns                          |
|                              | often-but-unpredictably       | ((b 1) (b 3) (b 4) (b 5) (c 2))  |
|                              | modifies the passed alist,    |                                  |
|                              | and so only the returned      |                                  |
|                              | alist should be used after    |                                  |
|                              | invoking this function.       |                                  |
| (rassq-delete-all key alist) | Like the last function but    |                                  |
|                              | compares CDRs to the given    |                                  |
|                              | key instead of CARs.          |                                  |
*** Q: When should I use apostrophes?
**** A: To return an object/variable name without evaluating it.
The code ='object= is short for =(quote object)=, which is a special
form that returns =object= without evaluating it. This is useful, for
instance, when you would like to change the value of a variable,
append elements to a list, add un-evaluated elisp code to some other
object, etc.

***** Example: A variable called =Paddington=
Let's say you have a variable named =Paddington=, and you wish to
replace its value with the string "A Bear Called Paddington". This can
be achieved as follows:
#+BEGIN_EXAMPLE emacs-lisp
  (setq Paddington "A Bear Called Paddington")
#+END_EXAMPLE
Note that quoting is unnecessary here, since =(setq foo bar)= sets the
/literal/ symbol =foo= to the value =bar= (so in some sense quotes
=Paddington= without our intervention).

Indeed, if you want to get unnecessarily fancy here (and to emphasize
what the apostrophe is doing) you could execute the following
equivalent code, too:
#+BEGIN_EXAMPLE emacs-lisp
  (setq Paddington (concat "A Bear Called " (symbol-name 'Paddington)))
#+END_EXAMPLE
Note that we can't just use =(concat "A Bear Called " 'Paddington)=
here, since ='Paddington= is really a /symbol/, not a /string/. (See
the emacs documentation for variables and symbols.)

***** Example: Prepending to a list
Suppose you have a list variable named =mylist= and you'd like to add
the string "A Bear Called Paddington" to it. In conjunction with the
=add-to-list= function, you can use quoting to achieve this:
#+BEGIN_EXAMPLE emacs-lisp
  (add-to-list 'mylist "A Bear Called Paddington")
#+END_EXAMPLE
You can also add the string to the end of this list by setting the first
optional argument of =add-to-list= to =t= (or anything non-nil).
*** Add an element to a list
**** Approach 1: (add-to-list ...)
#+BEGIN_EXAMPLE emacs-lisp
  (add-to-list LIST-VAR ELEMENT &optional APPEND COMPARE-FCN)
#+END_EXAMPLE

The =add-to-list= function prepends (by default) its second argument
=ELEMENT= to the value of the list variable in its first argument
=LIST-VAR= if it is not already present there. Adding anything non-nil
as an optional parameter =APPEND= makes =add-to-list= append the
second argument instead. Its final argument =COMPARE-FCN= (also
optional) may be a function for it to use instead of =eq= to determine
if the new element is equal to anything in the list. The new value of
the list is then returned.

***** Example 1: Unnamed =LIST-VAR=
To add 4 to an unnamed list containing 1, 2, and 3.

#+BEGIN_EXAMPLE emacs-lisp
  (add-to-list '(1 2 3) 4)
  ; Returns (4 1 2 3)

  (add-to-list '(1 2 3) 4 t)
  ; Returns (1 2 3 4)
#+END_EXAMPLE

***** Example 2: Named =LIST-VAR=
Suppose =mylist= is a variable with value =(3 2 1)=. Then we may
prepend 4 to =mylist= with the following command:

#+BEGIN_EXAMPLE emacs-lisp
  (add-to-list 'mylist 4)
#+END_EXAMPLE
**** Approach 2: (cons car cdr)
#+BEGIN_EXAMPLE emacs-lisp
  (setq foo (cons car cdr))
#+END_EXAMPLE
=cons= is /the/ list creation function in elisp, and most other
functions (presumably including =add-to-list=) are built on top of
it. The command =(cons car cdr)= (short for *cons*truct) creates a
*cons cell* (aka a *non-atomic s-expression" (itself short for
"*s*ymbolic expression")), which is an object consisting of an ordered
pair of pointers CAR and CDR. Each pointer can point to any Lisp
object. The pointers CAR and CDR are often identified (in the
documentation) with the objects they point to.

By definition (in Lisp) a *list* is a series of cons cells =C1=, =C2=,
..., =Cn=, where for =k = 1,2,...,n= the CAR of =Ck= is a Lisp object
and the CDR of =Ck= is =Ck+1=, except for the CDR of =Cn= which is
=nil= (or =()=, equivalently). If the list object in the CAR of Ck is
the symbol =eltk= for each =k=, then this looks like the following:
#+BEGIN_EXAMPLE emacs-lisp
  ;; Using cons:
  (cons elt1 (cons elt2 (cons elt3 [...] (cons eltn ()) [...])))
  ;; In dotted pair notation:
  '(elt1 . (elt2 . (elt3 [...] (eltn . ())...)))
  ;; As a list
  '(elt1 elt2 elt3 [...] eltn)
#+END_EXAMPLE
Note that each =eltk= doesn't have to be atomic (or a symbol in
particular); lists may contain other lists and objects as elements.
One way to represent these visually is as follows:

#+BEGIN_EXAMPLE
    --- ---      --- ---                --- ---
   |   |   |--> |   |   |--> [...] --> |   |   |--> nil
    --- ---      --- ---                --- ---
     |            |                      |
     |            |                      |
      --> elt1     --> elt2               --> eltn
#+END_EXAMPLE

So, in lisp, the following is a binary tree with labels only on its leaves:

#+BEGIN_EXAMPLE emacs-lisp
  ((((1) (2)) ((3) (4))) (((5) (6)) ((7) (8))))
#+END_EXAMPLE
*** Replace an element in an alist :cons:setf:assoc:assq:assq_delete_all:rassq_delete_all:
Use the [[help:assq-delete-all][assq-delete-all]] and [[help:rassq-delete-all][rassq-delete-all]] commands to delete all
elements in the alist with a given CAR or CDR, and then prepend the
element of the same CAR/CDR you were replacing to the resulting list,
and set the original list equal to the result.

#+BEGIN_EXAMPLE emacs-lisp
  (setq mylist '((car1 . cdr1) (car2 . cdr2) (car1 . cdr11) (car3 . cdr3)))
  (setq mylist (cons '(car1 . newcdr1) (assq-delete-all 'car1 mylist)))
  ; => mylist now equals ((car1 . newcdr1) (car2 . cdr2) (car3 . cdr3))
#+END_EXAMPLE

The [[help:assq-delete-all][assq-delete-all]] and [[help:rassq-delete-all][rassq-delete-all]] functions use, naturally, the [[help:assq][assq]]
function, which in turn relies on [[help:eq][eq]] for key comparison. This works great for
symbols and numbers but fails when keys are of a more general breed (including
strings).

Thankfully, there's more than one way to skin a cat, and some ways are better
than others for certain use cases. Let's say you know keys in the list are
unique and you only want to modify the value associated to a particular
key. This can be achieved (in alists and more generalized list-like objects)
using the *amazing* [[help:setf][setf macro]] together with the [[help:assoc][assoc]] function (instead of
[[help:assq][assq]]).

#+BEGIN_EXAMPLE emacs-lisp
  (setq mylist '(("some-key" . "some-value")
                 (some-other-key "a string" 1 2 3)
                 ("a key whose value you'd like to replace"
                  2 3 5 7 11 'all-the-other-primes)))

  (setf (cdr (assoc "a key whose value you'd like to replace" mylist))
        "the new value")

  ; => mylist now equals
  ;    (("some-key" . "some-value")
  ;     (some-other-key "a string" 1 2 3)
  ;     ("a key whose value you'd like to replace" "the new value"))
#+END_EXAMPLE

Study this second example well, since it's actually much more powerful and
intuitive than the first (not to mention more efficient). The =setf= macro opens
many doors and is a staple in Common Lisp code.

Note that =setf= could care less whether or not =mylist= is a bonafide
association list or something stranger. As you can see here, the use of =assoc=
here also enabled us to find an element with a string as a key. This is
frequently useful when, say, modifying variables with keys that are patterns to
match.
*** Concatenate lists
Use the [[help:append][append]] command.

#+BEGIN_EXAMPLE emacs-lisp
  (setq l1 '(a b c)
        l2 '(x y z))
  (append l1 l2)
  ;  => (a b c x y z)
#+END_EXAMPLE

Alternatively, use this other one-liner I cooked up while tired and fiddling
with lisp functions a long time ago. While both inefficient and destructive, it
introduces two other useful functions: [[help:nreverse][nreverse]] and [[help:mapcar][mapcar]]! (Warning: This
directly modifies the =a= and =b= variables. Use at your own risk!)

#+SRC_NAME destructive_and_inefficient_list_concatenation
#+BEGIN_EXAMPLE emacs-lisp
  (setq a ("1" "2" "3")
        b ("4" "5" "6"))
  (car (nreverse (mapcar (lambda (elt) (push elt b)) (nreverse a))))
  ;  => ("1" "2" "3" "4" "5" "6") as the value of b
#+END_EXAMPLE
*** Guide: Iterating          :NOTE:elisp:lists:Control_Structures:Guide:iteration:
Elisp has native support for [[help:while][while]] loops, which, when used in
conjunction with [[help:progn][progn]] provide extremely versatile ways to iterate on
files, buffers, lists, etc. There are also various do-loop commands, such
as the built-in [[help:dolist][dolist]] and [[help:dotimes][dotimes]] commands and the versatile [[help:do][do]]
command provided by Common Lisp. If, however, you are just interested
in applying a fixed function to every member of a list then [[help:mapcar][mapcar]] is
what you're looking for.
**** while + progn == until                            :while:progn:until:
Given the definitions of while and progn, the code block
#+BEGIN_EXAMPLE emacs-lisp
  (while (progn <sexp1>
                <sexp2>
                ...
                <sexpn>
                <sexpTest>))
#+END_EXAMPLE
will execute =<sexp1>=, =<sexp2>=, ..., =<sexpn>=, and =<sexpTest>=
and then pass the return value of =<sexpTest>= to =while= as the test
for whether or not =while= should continue. In other words, this is an
example implementation of the =repeat-until= control structure.

Note that the body of the above while loop is empty. You could make a
control structure where the expressions in =progn= are evaluated and,
if =<sexpTest>= is non-nil, then the code in the body would be called,
and then everything would repeat. Of course this could also have other
nested loops inside the test condition or body and any of them could
break out of the outer while loop using some mix of catch-throw or
encapsulation in other progn calls. For readability and simplicity of
maintenance, however, it's usually best to minimize having multiple
break points as described here and, instead, incorporate possible
break points into the progn test for the outer while loop; what you've
written in a nest chain of loops as described can usually be flattened
into a more readable single while loop.
** Style Guide                                      :NOTE:elisp:Style_Guide:
Perhaps the simplest-albeit-complete, community-driven, and sensible
style guide is bbatsov's [[https://github.com/bbatsov/emacs-lisp-style-guide][Emacs Lisp Style Guide]] on GitHub. I need to
incorporate these changes into my older code and, ideally, setup
auto-fill to handle as much of this as possible and not encourage bad
practices.
*** Source Code Layout & Organization
**** Use spaces for indentation
**** For regular (that is, non-special[fn:specialfcn]) functions, vertically align function arguments
#+BEGIN_EXAMPLE emacs-lisp
  ;; Good
  (format "%s %d"
          something
          something-else)

  ;; Bad
  (format "%s %d"
    something
    something-else)
#+END_EXAMPLE
**** If the first argument /is on a new line/, align it with the function's name
#+BEGIN_EXAMPLE emacs-lisp
  ;; Good
  (format
   "%s %d"
   something
   something-else)

  ;; Bad
  (format
    "%s %d"
    something
    something-else)
#+END_EXAMPLE
**** Whitespace rules for special forms[fn:specialfcn]
The special argument(s) should be either on the same line as the form
name or indented by 4 spaces. The non-special arguments should be
indented by 2 spaces. It should not be aligned like a regular
function.
#+BEGIN_EXAMPLE emacs-lisp
  ;; Good
  (when (condition)
    (action))

  ;; Bad
  (when (condition)
      (action))

  ;; Bad
  (when (condition)
        (action))

  ;; Bad
  (when
    (condition)
    (action))
#+END_EXAMPLE
***** Example: =if= forms
The if-clause (executed when the condition passed to if is non-nil) is
a special argument, so it is indented by 4 spaces.
#+BEGIN_EXAMPLE emacs-lisp
  ;; Good
  (if (condition)
      (if-clause)
    (else-clause))

  ;; Bad
  (if (condition)
    (if-clause)
    (else-clause))
#+END_EXAMPLE
**** Vertically align =let= bindings
#+BEGIN_EXAMPLE emacs-lisp
  ;; Good
  (let ((animalName "elephant")
        (woof "Woof!"))
    (body-clause)
    ...)

  ;; Bad
  (let ((animalName "elephant")
    (woof "Woof!"))
    (body-clause)
    ...)
#+END_EXAMPLE
**** Always use CRLF (Unix) line endings
**** Separate text on the "outside" of brackets from the brackets by a space but not on the inside
#+BEGIN_EXAMPLE emacs-lisp
  ;; Good
  (foo (bar baz) qux)

  ;; Bad
  (foo(bar baz)qux)
  (foo( bar baz )qux)

  ;; Are you even trying anymore?
  ( foo ( bar baz ) qux )
#+END_EXAMPLE
**** Place all trailing parentheses on the same line, in contact with the last form
#+BEGIN_EXAMPLE emacs-lisp
  ;; Good
  (when (foo)
    (bar))

  ;; Bad
  (when (foo)
    (bar)
  )
#+END_EXAMPLE
**** With few exceptions, separate top-level forms with an empty line
#+BEGIN_EXAMPLE emacs-lisp
  ;; Good
  (defvar foo ...)

  (defun bar ...)

  ;; Bad
  (defvar foo ...)
  (defun bar ...)
#+END_EXAMPLE
***** Exception: When group related definitions together
#+BEGIN_EXAMPLE emacs-lisp
  ;; Good
  (defconst min-rows 10)
  (defconst max-rows 20)
  (defconst min-cols 15)
  (defconst max-cols 30)
#+END_EXAMPLE
** Org Mode Notes and Techniques                                       :Org:
*** Edit a code block in its default major mode (e.g. =lisp-mode= or =LaTeX-mode=)
While the pointer is in the code block hit C-c ' to open a new frame
in the correct mode containing just this code block. Hit C-x C-s to
save changes in the original buffer without closing the new one. Hit
C-c ' again to apply changes to the code block in the org file.
** Magit Notes                                                   :Magit:Git:
*** Q: How can I create a new branch from current changes and revert the current branch? :QUESTIONS:
**** A: Create a "spinoff" branch (via 'b s')
See the documentation for [[help:magit-branch-spinoff][magit-branch-spinoff]].

Here's a common problem I have. I like to tweak my configuration files
quite a bit, both on my laptop and on my office iMac, and sometimes
I'll absent mindedly make nominally conflicting changes to the same
config file on both machines. For instance, I could go to the office
to quickly grind out a writeup of some result, and realize as I'm
doing so that there is something annoying and Aquamacs-centric I need
to tweak in my config file. Naturally I'll make that change, commit it
to the working branch of the repository, and push to the remote.

Later, I might be working from home on my laptop and have some big
change I want to make and spend several hours implementing some neat
config hack. This can take several commits and plenty of time, and
once I'm done (or, worse yet, when I'm halfway through but at a
reasonable stopping point) I'll try to push these changes to the
remote. Of course, that's when I'll realize my mistake, namely that I
didn't pull the changes from the office or start a new branch several
hours ago. Now, hopefully, the changes from the office can be easily
merged into my config files without any issues, but what about when I
know I've made edits to the same portions of the files? Do I really
want to have to deal with resolving merge conflicts or reverting local
changes? Of course not! But the other options like stashing or
manually moving all of the local commits to a new branch can be quite
tedious at times.

That's where creating spinoff branches comes into play. For the sake
of argument, let's say the branch I'm working on in the last paragraph
is =foo=. Well, if I tell Magit (from my laptop) to create a spinoff
branch named =bar= of my repository, it will
 1. Find the last commit common to =foo= and its upstream,
 2. Take all of the commits to =foo= after that commit and move them
    into the new =bar= branch, and
 3. Revert =foo= to the upstream commit.
Simple as that! Suddenly I can pull changes made at the office to my
local repo, push the commits pertaining to my current project to the
remote, and have several more flexible ways to address any merge
conflicts locally (and when I see fit not when I want to push
changes).
* Startup
** Set Up drmrd Customization Group                           :drmrd:custom:
#+SRC_NAME setup_drmrd_custom_group
#+BEGIN_SRC emacs-lisp
  (defgroup drmrd nil
    "Settings for drmrd's configuration files."
    :prefix "drmrd/"
    :group 'emacs
    :version "25.1")

  (defcustom drmrd/home-directory
    (let ((home-envvar (getenv "HOME"))
          (user-emacs-directory-parent
           (file-name-directory (directory-file-name user-emacs-directory))))
      (if (and home-envvar (file-directory-p home-envvar))
          home-envvar
        (progn
          (display-warning
           'drmrd
           (concat "Your HOME environment variable is not set. "
                   "We highly recommend setting this variable to avoid surprises "
                   "when using these Emacs configuration files. As a fallback, "
                   "we are setting your home directory "
                   "(in `drmrd/home-directory') to the parent of your Emacs "
                   "configuration directory: \""
                   user-emacs-directory-parent "\".")))))
    "The home directory for the current user.

  This is set to the value of the HOME environment variable by default.  If no
  HOME environment variable exists, a warning is displayed, and
  `drmrd/home-directory' will be set to the parent of `user-emacs-directory'."
    :type '(directory)
    :group 'drmrd
    :version "25.1")

  (defcustom drmrd/secrets-directory (concat user-emacs-directory "secure/")
    "A directory that contains private information.

  Credentials and other data that shouldn't be included in your emacs.d Git
  repository should be stored here."
    :type '(directory)
    :group 'drmrd
    :version "25.1")

  (defcustom drmrd/lib-directory (concat user-emacs-directory "lib/")
    "The root directory for libraries loaded by `drmrd' configuration files.

  This is used, for instance, for convenient loading of library files by
  `drmrd/load-library'."
    :type '(directory)
    :group 'drmrd
    :version "25.1")
#+END_SRC
** Enable Debugging/Detailed Timestamps
Enable debugging while loading configuration files. This is disabled later in
the config file after initialization has finished.

#+BEGIN_SRC emacs-lisp
  (setq debug-on-error t)
  (setq debug-on-quit t)
#+END_SRC

Now start tracking how long loading config files takes.

#+BEGIN_SRC emacs-lisp
  ;;; Use the following time format in format-time-string calls when
  ;;; debugging/benchmarking the init file.
  (setq drmrd/debug/timeformat "%I:%M%p (%S.%3Ns)")

  (message (concat "Loading Emacs configuration started at "
                   (format-time-string drmrd/debug/timeformat)))
#+END_SRC
** Benchmark Initialization                                       :DISABLED:
The following code, based on [[https://www.reddit.com/r/emacs/comments/2094tl/how_can_i_improve_emacs_performance/cg0ydzc][this reddit comment from wadcann]] makes it
so that messages are posted to the *Messages* buffer with timestamps
as Emacs loads, providing a way to analyze which packages, functions,
etc. are eating up the most startup time.
#+BEGIN_SRC emacs-lisp :tangle no
  ;;; Timestamps in *Messages* at startup
  (defun drmrd/debug/message-time-prefix ()
    "Returns the string \"[TIME] \" where `TIME' is the current
    time, in the format specified by `drmrd/debug/timeformat'. This
    will be used to insert timestamps before each command in the
    `*Messages*' buffer during (and after) startup."
    (let* ((nowtime (current-time))
           (now-ms (nth 2 nowtime)))
          (concat "["
                  (format-time-string drmrd/debug/timeformat)
                  "] ")))

  (defadvice message (before test-symbol activate)
    (if (not (string-equal (ad-get-arg 0) "%s%s"))
        (let ((deactivate-mark nil)
              (inhibit-read-only t))
          (with-current-buffer "*Messages*"
            (goto-char (point-max))
            (if (not (bolp))
                (newline))
            (insert (drmrd/debug/message-time-prefix))))))
#+END_SRC
** Load Package Manager and Package-Loader :package_management:use_package:quelpa:
*** +Configure =package=+
+The following code loads =package= for package management, sets the+
+default package repositories, and then initializes =package=.+

+Load Package, load all default packages, and link to all standard+
+package repositories.+

+We first ensure that the Package package for package management+
+(that's a mouthful!) has been loaded. Then we call package-initialize,+
+which loads all packages specified in the variable+
+package-load-list. After loading the default packages, we redefine the+
+package-archives list to include ELPA, GNU, MELPA, and Marmalade.+

*Update:* I now do all of the above in [[file:.emacs][~.emacs~]] instead, so that I can
initialize =package= before calling =org= for the first time. This ensures that
an up-to-date version of =org= from ELPA is loaded instead of the built-in one.
*** Bootstrap =use-package=
Next, we ensure that =use-package= is installed on our system.

It's mentioned in the [[https://github.com/jwiegley/use-package][use-package README on GitHub]] that it's no longer
necessary (as of v2.0) to load =use-package= at runtime. It suggests
putting the following code at the start of our config, which uses
=eval-when-compile= to load =use-package= only when necessary, further
reducing load time.

#+SRC_NAME use-package_bootstrap
#+BEGIN_SRC emacs-lisp
    ;; Install `use-package' (if not already done)
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package))

    ;; Lazily load use-package, and also load the diminish and bind-key
    ;; packages for hiding messages from active modes in the modeline with
    ;; :diminish and easily setting keybindings with :bind.
    (eval-when-compile
      (require 'use-package))

    (unless (package-installed-p 'diminish)
      (package-refresh-contents)
      (package-install 'diminish))

    (require 'diminish)
    (require 'bind-key)
#+END_SRC

We also ensure that all packages we ~use~ through ~use-package~ are downloaded
and installed by default when no local version is present.

#+SRC_NAME use-package_configuration
#+BEGIN_SRC emacs-lisp
  ;; Install packages from a repo that we attempt to load but are not
  ;; present on the system.
  (setq use-package-always-ensure t)
#+END_SRC
*** Bootstrap ~quelpa~, the 'package' manager for source repositories
[[https://github.com/quelpa/quelpa][~quelpa~]] is a fantastic solution to the problem of installing Emacs list
libraries from GitHub, EmacsWiki, and other sources that aren't provided the
conventional package structure required for (or at least aren't mirrored in)
ELPA, MELPA, etc. Instead, ~quelpa~ clones source repositories and wraps the
source code in the necessary package syntax automatically. That way the
installed source code is not only available to the user but also recognized by
Emacs as providing features, etc.

~quelpa~ can also be used to install other Emacs packages straight
from source, regardless of whether or not they're packages. For instance,
~(quelpa 'magit)~ will "will fetch the magit source code from GitHub, build a
package in the ELPA format, and install it". It can also be called interactively
to install packages from MELPA recipes and their dependencies.

The package ships with a bootstrapper and encourages allowing it to upgrade
itself. The following code is their recommended install and auto-upgrade
logic:

#+SRC_NAME quelpa_bootstrap
#+BEGIN_SRC emacs-lisp :tangle no
  (ignore-errors
    (if (require 'quelpa nil t)
        (quelpa-self-upgrade)
      (with-temp-buffer
        (url-insert-file-contents "https://raw.github.com/quelpa/quelpa/master/bootstrap.el")
        (eval-buffer))))
#+END_SRC

As you can probably guess, replacing the ~if~ with an ~unless~ and removing the
~(quelpa-self-upgrade)~ call leaves you with just the bootstrapper (if you don't
trust its self-upgrading functionality). Also, we call ~ignore-errors~ to avoid
an error being signalled by ~url-insert-file-contents~ when working offline.

We also install ~quelpa-use-package~, which adds a ~:quelpa~ keyword to
~use-package~, which enables ~use-package~ to install from source, as well.

#+SRC_NAME quelpa-use-package_quelpa_install
#+BEGIN_SRC emacs-lisp :tangle no
  (quelpa
   '(quelpa-use-package
     :fetcher github
     :repo "quelpa/quelpa-use-package"))
  (require 'quelpa-use-package)
#+END_SRC

See the [[https://github.com/quelpa/quelpa-use-package][~quelpa-use-package~ repo]] for usage examples and more.

The following macro is [[https://github.com/jwiegley/use-package/issues/471#issuecomment-308503507][due to joewreschnig]] on GitHub and makes using the
~:quelpa~ keyword with GitHub projects a bit more readable. Note that I've
swapped the order of the keyword and the ~body~ form found in the original
version, since conditional keywords in the ~body~ won't work as expected unless
they occur prior to the ~quelpa~ line.

#+SRC_NAME use-github-package_defmacro
#+BEGIN_SRC emacs-lisp :tangle no
  (defmacro use-github-package (name repo &rest body)
    "Fetch package NAME from GitHub repository REPO, and use it.

  Any forms appropriate for `use-package' may be passed in BODY."
    (declare (indent 2))
    (quelpa-use-package-activate-advice)
    `(use-package ,name
       ,@body
       :quelpa (,name :repo ,repo :fetcher github))
    (quelpa-use-package-deactivate-advice))
#+END_SRC
* Appearance & UI                                             :Appearance:UI:
** Clean Up GUI Elements                                 :Toolbar:Scrollbar:
#+SRC_NAME disable_GUI_elements
#+BEGIN_SRC emacs-lisp tangle: yes
  (when (display-graphic-p)
    (tool-bar-mode 0)
    (scroll-bar-mode 0))

  (defun drmrd/disable-scroll-bars (frame)
    (modify-frame-parameters frame
                             '((vertical-scroll-bars . nil)
                               (horizontal-scroll-bars . nil)
                               (tool-bar-lines . nil)
                               (menu-bar-lines . nil))))

  (add-hook 'after-make-frame-functions 'drmrd/disable-scroll-bars)
#+END_SRC
** Miscellany
*** Set Default Font(s)                                             :Fonts:
Naturally, fonts are quite OS and machine-specific, so this portion of the
configuration will probably grow a bit with time. For now, the following
configuration is appropriate. On Mac OS X, the Vera Sans font family is used,
while on Linux we employ DejaVu Sans Mono.
#+BEGIN_SRC emacs-lisp
  (defcustom drmrd/preferred-default-font-families
    '("Source Code Pro"
      "DejaVu Sans Mono"
      "inconsolata"
      "Lucida Console"
      "courier"
      "Menlo")
    "The list of font families to attempt to use by default.

  Font family names should be listed in descending order of preference."
    :tag "List of preferred default font families (descending order)"
    :type '(repeat string)
    :group 'drmrd)

  (defcustom drmrd/default-font-size 12
    "The default font size to be used in Emacs."
    :tag "Default font size in Emacs"
    :type 'integer
    :group 'drmrd)

  (defun drmrd/font-family-exists-p (font-family)
    "Determine if a given font family exists on this computer.

  Returns non-nil if FONT-FAMILY is the name of a font known to Emacs."
    (car (member font-family (font-family-list))))

  (defun drmrd/default-font-string ()
    (let ((font-family (cl-some 'drmrd/font-family-exists-p
                                drmrd/preferred-default-font-families)))
      (concat font-family "-" (number-to-string drmrd/default-font-size))))

  (set-face-attribute 'default nil :font (drmrd/default-font-string))
#+END_SRC
*** Disable Cursor Blinking                                   :CursorBlink:
The enemy of civil society. I disable cursor blinking not only
because I find it obnoxious and distracting, but because it's *the
right thing to do*.
#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode -1)
#+END_SRC
** Mode Line                                                       :ModeLine:
*** Show column numbers                                       :ColumnNumbers:
#+SRC_NAME enable_column-number-mode
#+BEGIN_SRC emacs-lisp
  (column-number-mode 1)
#+END_SRC
*** Show the current time                                            :Time:
#+BEGIN_SRC emacs-lisp
  (display-time)
#+END_SRC
*** nyan-mode                                                     :nyan_mode:
Display current location in buffer as a magical rainbow behind a poptart cat
#+SRC_NAME nyan-mode-setup
#+BEGIN_SRC emacs-lisp
  (use-package nyan-mode
    :ensure t
    :init
    (setq nyan-wavy-trail t
          nyan-minimum-window-width 80
          nyan-bar-length 20)
    (nyan-mode))
#+END_SRC
*** TODO smart-mode-line (sml)                          :sml:smartmodeline:
Extend and customize the modeline. Use =sml/customize= (or go to the customize
group) to tweak variables that affect the modeline's theming, what is displayed,
and how it's displayed.

Really a fantastic package. My only issue currently is that it's messing with
the theme I'm using. I should read the docs more to see if I'm loading things in
the wrong order or something.

Need to tweak this to avoid errors.

#+SRC_NAME powerline_use-package
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package powerline :ensure t)
#+END_SRC

#+SRC_NAME smart-mode-line_use-package
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package smart-mode-line :ensure t
    :after powerline
    :init
      (setq sml/no-confirm-load-theme t)
    :config
      (sml/setup))
#+END_SRC
*** Hide/tweak minor mode lighters   :ModeLighters:delight:Functions:drmrd:
Pretty much every mode known to mankind defines its own *mode lighter*, which is
to say some kind of message that appears in the mode line when the mode is
active. Since the mode line is prime real estate, it's useful to pare down the
messages broadcast by all these modes.

The following list's entries describe modes I use frequently and don't care to
see in the mode line.

#+SRC_NAME set_drmrd/adjusted-mode-lighters
#+BEGIN_SRC emacs-lisp
  (defcustom drmrd/adjusted-mode-lighters
    '((button-lock-mode nil "button-lock")
      ; (fixmee-mode nil "fixmee")
      (git-gutter-mode nil "git-gutter")
      (guide-key-mode nil "guide-key")
      (outline-minor-mode nil "outline")
      (projectile-mode nil "projectile")
      (reftex-mode nil "reftex")
      (undo-tree-mode nil "undo-tree")
      (visual-line-mode)
      (ws-butler-mode nil "ws-butler")
      (yas-minor-mode nil "yasnippet"))
    "Specifies modes whose mode line indicators (a.k.a. 'mode lighters') should be
  suppressed or replaced (and provides a replacement scheme).  Each entry takes
  the form (mode &optional lighter library), where MODE is the mode's name,
  LIGHTER is the string (or function returning a string) with which the default
  mode lighter for MODE should be replaced, and LIBRARY is the library that
  provides MODE."
    :tag "Adjusted Minor Mode Lighters in the Mode Line"
    :type '(repeat sexp)
    :group 'drmrd)
#+END_SRC

The =delight= package simplifies the process of removing/modifying major and
minor mode lighters (text indicators) appearing in the mode-line.

#+SRC_NAME delight_use-package
#+BEGIN_SRC emacs-lisp
  (use-package delight :ensure t
    :config (delight drmrd/adjusted-mode-lighters))
#+END_SRC

The following function can be used to load another mode and delight it all at
the same time.

#+SRC_NAME defun_drmrd/load-delighted-mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun drmrd/load-delighted-mode(mode value library)
    "Load mode MODE from LIBRARY and set its mode lighter to VALUE.

  This function is intended for use in hooks, but works equally well when
  evaluated manually."
    (interactive)
    (funcall mode)
    (diminish mode value library))
#+END_SRC
** Theming                                                          :Themes:
*** Have load-theme unload other color themes before loading new ones
I have no idea why this isn't the default behavior. See
[[http://emacs.stackexchange.com/a/3114/8643][this post]] for a good overview of color-themes, disabling theme when
loading new ones, and the pros and cons of using color-theme vs
Emacs24's built-in custom themes.
#+BEGIN_SRC emacs-lisp
  (defadvice load-theme (before theme-dont-propagate activate)
                        (mapc #'disable-theme custom-enabled-themes))
#+END_SRC
*** Install/Load Themes
#+SRC_NAME install_themes
#+BEGIN_SRC emacs-lisp
  (use-package color-theme-sanityinc-tomorrow :ensure t)
  (use-package sublime-themes :ensure t)
  (use-package paganini-theme :ensure t)
  (use-package avk-emacs-themes :ensure t)
  ; (use-package aanila :ensure t)
  (use-package lush-theme :ensure t)
  (use-package molokai-theme :ensure t)
  (use-package monokai-theme :ensure t)
  ;; FIXME (2024-03-03): Unable to find spacemacs-common during init.
  ;; (use-package spacemacs-common :ensure spacemacs-theme)
#+END_SRC

Now we load our current favorite theme. This changes regularly.
#+SRC_NAME load_a_theme
#+BEGIN_SRC emacs-lisp
  (message "DRMRD Debug: Loading theme")
  (load-theme 'sanityinc-tomorrow-day t)
#+END_SRC
**** (Obsolete) Using color-theme to load a theme
(I've kept these notes here for reference, in case I'm stranded on a
desert island with no internet and an old copy of Emacs. They are
irrelevant in versions beyond v24.)

Color-Theme Mode is Emacs's standard theming engine for customizing
faces throughout the UI and editor. We first load the package and
initialize it.

#+BEGIN_SRC emacs-lisp :tangle no
  (require 'color-theme)
  (color-theme-initialize)
#+END_SRC

Now we choose a color theme to load. I've commented out several other
nice candidates, and other themes showing potential should also be
added here.

#+BEGIN_SRC emacs-lisp :tangle no
  ;(color-theme-bharadwaj-slate)
  (color-theme-charcoal-black)
  ;(color-theme-classic)
  ;(color-theme-deep-blue )
  ;(color-theme-ld-dark)
  ;(color-theme-midnight)
  ;(color-theme-pok-wog)
  ;(color-theme-resolve)
  ;(color-theme-shaman)
  ;(color-theme-subtle-hacker)
#+END_SRC
** Display Line Numbers                                 :nlinum:LineNumbers:
Ah yes, the somewhat notorious problem of displaying line numbers in Emacs in a
way that doesn't break/get terribly affected by different modes and font locking
schemes. Most recently I've been using nlinum mode for this purpose, but I can't
seem to use it while loading multiple frames. This is only an issue on my
laptop, not at the office, so I'm now testing to see if it's some kind of timing
issue.

#+SRC_NAME nlinum-mode_use-package
#+BEGIN_SRC emacs-lisp
  (use-package nlinum :ensure t
    :config ;; (add-hook 'prog-mode-hook (lambda () (nlinum-mode t)))
    (if (< emacs-major-version 25)
        (progn
          (message "emacs version < 25, will not use nlinum globally,
        using workaround")
          ;; nlinum workaround
          (defun initialize-nlinum (&optional frame)
            (require 'nlinum)
            (add-hook 'prog-mode-hook 'nlinum-mode))
          (when (daemonp)
            (add-hook 'window-setup-hook 'initialize-nlinum)
            (defadvice make-frame (around toggle-nlinum-mode compile activate)
              (nlinum-mode -1) ad-do-it (nlinum-mode 1))))
      (progn
        (message "emacs version >= 25, will use nlinum globally")
        (require 'nlinum)
        (global-nlinum-mode 1)
        ;; specify line number format
        (unless window-system
          (setq nlinum-format "%d "))))
    :bind (("C-c t l" . nlinum-mode)))

    ;; (defun initialize-nlinum (&optional frame)
    ;;        (require 'nlinum)
    ;;        (add-hook 'prog-mode-hook 'nlinum-mode))

    ;; (add-hook 'window-setup-hook 'initialize-nlinum)
    ;; (defadvice make-frame (around toggle-nlinum-mode compile activate)
    ;;            (nlinum-mode -1) ad-do-it (nlinum-mode 1))
#+END_SRC
** Highlight the Current Line                      :hlline:LineHighlighting:
Highlights the current line in every buffer by default
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-hl-line-mode 1); Highlight current line in buffer
#+END_SRC
** Set Default Frame Dimensions                                   :FrameSize:
#+SRC_NAME set_default_frame_dimensions
#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist '(width  . 90))
  (add-to-list 'default-frame-alist '(height . 50))
#+END_SRC
** git-gutter-fringe                     :gitgutterfringe:Git:UI:Diff:Fringe:
Displays a minimalist indicator in the fringe (side margin) of changes made to
the current file since the last commit. After seeing this in Sublime Text and
IntelliJ IDEA I'm hooked. It's amazingly useful without getting in the way.

=git-gutter-fringe= is based on its sibling mode =git-gutter=, which instead
displays diff information in the gutter of each line
buffers. Both are developed by syohex on GitHub:

  - [[github:syohex/emacs-git-gutter][git-gutter]]
  - [[github:syohex/emacs-git-gutter-fringe][git-gutter-fringe]]

#+SRC_NAME git-gutter-fringe_use-package
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter-fringe
      ;; Move fringe to the right margin
      :init (setq git-gutter-fr:side 'right-fringe)
      :config
      (progn
        (global-git-gutter-mode t)
        (git-gutter:linum-setup))
      :ensure t
      :diminish t)
#+END_SRC

** Rainbow Delimiters
The [[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] package highlights nested parentheses, braces, and other
delimiters in distinct colors. It's *phenomenal* when writing lisp and LaTeX
code. We load it in all programming modes by default.
#+NAME load_and_enable_rainbow-delimiters_in_prog_modes
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :init
    (progn
      (cl-dolist (mode-hook '(prog-mode-hook tex-mode-hook latex-mode-hook
                                             TeX-mode-hook LaTeX-mode-hook))
        (add-hook mode-hook #'rainbow-delimiters-mode))))
#+END_SRC
** Visual Error Sounds (Visual Alarm Bell)
Among Emacs's most celebrated, modern features is the obnoxious audible bell it
plays at every error. This informs you of your own egregious errors, triggering
a loud "ding" when you, say, attempt to move forward past the end of a buffer by
hitting =C-v=. If, for whatever reason, you would prefer to not have these
constant reminders of your own failings, you can set the =visible-bell= variable
to something non-=nil= to substitute the bell with a subtle visual indicator.

If the visual indicator is too much for you on your machine (like on macOS,
where it's a giant exclamation mark icon), you can also set the
=ring-bell-function= to anything you'd like in response to errors. It can also
be set to a function that does nothing in order to disable audio and visual
error notifications altogether, like I've done below.

#+SRC_NAME visible_bell_sound
#+BEGIN_SRC emacs-lisp
  ;(setq visible-bell t)
  (setq ring-bell-function (lambda ()))
#+END_SRC
* Navigation & Window Management                                 :Navigation:
** ace-jump: Quickly move around in a buffer      :ace_jump:BufferNavigation:
#+SRC_NAME ace-jump_use-package
#+BEGIN_SRC emacs-lisp
  (use-package ace-jump-mode
    :ensure t
    :bind ("C-." . ace-jump-mode))
#+END_SRC
** Ido Mode (Better, Interactive find-file Command) :ido:Completion:FileNavigation:
Enable Ido Mode for a much improved buffer and file switching/finding
experience. Configuring Ido Mode, based on the settings in [[http://xgarrido.github.io/emacs-starter-kit/starter-kit-ido.html][xgarrido's
Emacs Starter Kit]].

*** Update (2024-03-03): Replaced with Helm mode
I've replaced Ido mode with Helm mode in my configuration. Since Helm now
returns an error if Ido mode is enabled, I'm no longer tangling any Ido mode
configuration. It remains in this section as a useful reference for now, but
I'll be removing it once I am confident my Helm configuration is working as
desired.

*** Enable Ido Mode
#+SRC_NAME: enable-ido-mode
#+BEGIN_SRC emacs-lisp :tangle no
  (ido-mode t)
#+END_SRC

*** Basic Configuration
Next, we change some basic settings to make our lives easier. The
following table describes each setting. Note that, for Boolean
variables, the Description column shows the behavior if non-nil, with
the behavior being the opposite if nil (unless otherwise specified).

|-----------------------+----------------------------------+----------------------------|
| Setting (ido-[...])   | Description                      | Possible Values            |
|-----------------------+----------------------------------+----------------------------|
| everywhere            | Enable Ido Everywhere            | Boolean                    |
| enable-prefix         | Match input only if prefix       | Boolean                    |
| enable-flex-matching  | If no string match, match        | Boolean                    |
|                       | filenames containing input chars |                            |
| auto-merge-work       | Auto switch to merged work       | Integer N (disable if < 0) |
| -directories-length   | directories after N typed chars  |                            |
| use-filename-at-point | Use filename at point?           | Boolean                    |
| max-prospects         | Max number of results to display | Integer N >= 0             |
|                       | (infinite if set to 0)           |                            |
| create-new-buffer     | Create a new buffer if no buffer | 'always                    |
|                       | matches substring?               | 'prompt                    |
|                       |                                  | 'never                     |
| use-virtual-buffers   |                                  | Boolean                    |
|                       |                                  |                            |
| default-buffer-method | Determines where/how the         | selected-window            |
|                       | selected buffer is opened        | other-window               |
|                       |                                  | display                    |
|                       |                                  | other-frame                |
|                       |                                  | maybe-frame                |
|                       |                                  | raise-frame                |
|                       |                                  | already shown              |
| default-file-method   | Determines where/how the         | Same as                    |
|                       | selected file is opened          | default-buffer-method      |
|-----------------------+----------------------------------+----------------------------|

|------------------------------------------------------------------------------------------|
| Notes                                                                                    |
|------------------------------------------------------------------------------------------|
| Several options mention =virtual buffers=, which are ido-mode's way of pretending        |
| recently-closed buffers are open. So, for instance, if you set =ido-use-virtual-buffers= |
| to =t=, ido-mode will keep a list of recently-closed buffers at the bottom of the buffer |
| list (displayed in the font-face =ido-virtual=), enabling you to, e.g., switch to        |
| recently-closed buffers after you exit and re-open Emacs.                                |
|------------------------------------------------------------------------------------------|

#+SRC_NAME: ido-mode-basic-config
#+BEGIN_SRC emacs-lisp :tangle no
  (setq ido-everywhere            t
        ido-enable-prefix         nil
        ido-enable-flex-matching  t
        ido-auto-merge-work-directories-length nil
        ido-use-filename-at-point t
        ido-max-prospects         10
        ido-create-new-buffer     'always
        ido-default-buffer-method 'selected-window
        ido-default-file-method   'selected-window)
#+END_SRC

*** Custom Keybindings
Since we will configure Ido Mode to [[*Order%20Results%20Vertically][order results vertically]] below,
rather than horizontally, we will also make the up and down arrow keys
move up and down the list of results for easy browsing.

#+SRC_NAME: ido-mode-custom-keybindings
#+BEGIN_SRC emacs-lisp :tangle no
  (defun ido-my-keys ()
    (define-key ido-completion-map (kbd "<up>")   'ido-prev-match)
    (define-key ido-completion-map (kbd "<down>") 'ido-next-match))

  (add-hook 'ido-setup-hook 'ido-my-keys)
#+END_SRC

*** Order File Extensions
Set the order in which Ido displays files based on their extensions.
#+SRC_NAME: ido-mode-extension-order
#+BEGIN_SRC emacs-lisp :tangle no
  (setq ido-file-extensions-order '(".tex" ".org" ".log" ".cc"
                                    ".h" ".sh" ".el" ".png"))
#+END_SRC

*** Set Ignored File Extensions and Buffers
The following settings tell Ido Mode to ignore various types of files
and buffers that we never actually look up/attempt to switch to.

#+SRC_NAME: ido-mode-ignored-extensions-and-buffers
#+BEGIN_SRC emacs-lisp :tangle no
  (setq completion-ignored-extensions '(".o" ".elc" "~" ".bin" ".bak"
                                        ".obj" ".map" ".a" ".so"
                                        ".mod" ".aux" ".out" ".pyg"
                                        ".bbl" ".blg" ".idx" ".ilg"
                                        ".ind" ".rel" ".synctex.gz"
                                        "_flymake.bcf" "_flymake.dvi"
                                        "_flymake.run.xml"
                                        "_flymake.tex" ".fdb_latexmk"
                                        ".fls" ".DS_Store"))
  (setq ido-ignore-extensions t)
  (setq ido-ignore-buffers (list (rx (or (and bos  " ")
                                         (and bos
                                              (or "*Completions*"
                                                  "*Shell Command Output*"
                                                  "*vc-diff*")
                                              eos)))))
#+END_SRC
**** TODO Create a new function/keybinding that lists EVERYTHING in the directory
This would be nice for, e.g., hacking intermediate TeX files on the
rare occasions when that's useful/necessary.

*** Allow Spaces in ido-find-file
By default, pressing [Space] does nothing when using ido-find-file,
which makes it difficult to search with several words that you know
occur in the file name. This snippet changes this behavior to be more
intuitive.

#+SRC_NAME: ido-mode-enable-spaces
#+BEGIN_SRC emacs-lisp :tangle no
  (add-hook 'ido-make-file-list-hook
            (lambda ()
              (define-key ido-file-dir-completion-map (kbd "SPC") 'self-insert-command)))
#+END_SRC

*** Order Results Vertically & Change Ido Result Formatting
By default Ido Mode displays results in a multi-line horizontal list,
which is, frankly, difficult to read at times. This code makes Ido
list results in a vertical list instead.

#+SRC_NAME: ido-mode-list-results-vertically
#+BEGIN_SRC emacs-lisp :tangle no
  (setq ido-decorations (quote ("\n-> "   ""      ; The "brackets" around the
                                                  ; entire prospect list
                                "\n "             ; The prospect separator
                                "\n ..."          ; String inserted at end of a
                                                  ; truncated list of prospects
                                "["       "]"     ; Brackets around the common
                                                  ; match string (that can be
                                                  ; completed using [Tab])
                                " [No match]"     ; The string to display when
                                                  ; there are no matches
                                " [Matched]"      ; The string to display when
                                                  ; there is a unique match (and
                                                  ; faces are not being used)
                                " [Not readable]" ; The string to display when
                                                  ; the current directory is not
                                                  ; readable
                                " [Too big]"      ; The string to display when
                                                  ; the current directory
                                                  ; is > ido-max-directory-size
                                " [Confirm]"      ; The string to display when
                                                  ; creating a new file buffer
                                ; Absent 12th & 13th strings:
                                ; Brackets around the sole remaining completion,
                                ; if they should differ from 5 and 6.
                        )))
  (defun ido-disable-line-truncation () (set (make-local-variable 'truncate-lines) nil))
  (add-hook 'ido-minibuffer-setup-hook 'ido-disable-line-truncation)
#+END_SRC

** SMEX Mode (Ido for M-x)               :smex:Completion:Mx:FileNavigation:
Replace the usual M-x keybinding with an equivalent that also list all
completions of the partial command name you've typed in much the same
way Ido Mode does for buffers and files.

#+SRC_NAME: configure-smex
#+BEGIN_SRC emacs-lisp
  (use-package smex
    :bind
      ("M-x" . smex)
      ("M-X" . smex-major-mode-commands))
#+END_SRC

** Recentf (Track Recent Files, Load via C-x C-r)   :recentf:FileNavigation:
#+SRC_NAME load-and-configure-recentf
#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :init
      (setq recentf-max-menu-items 50)
    :config
      (recentf-mode)
      (add-to-list 'recentf-exclude "ido.last")
    :bind
      ("C-x C-r" . recentf-open-files))
#+END_SRC

** Bookmarks+                           :bookmarks+:Bookmarks:FileNavigation:
#+SRC_NAME bookmark+_use-package
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package bookmark+ :ensure t)
#+END_SRC
** TODO Dired+: Extensions to Dired               :diredplus:FileNavigation:
** ace-window: Easy Window Navigation with M-p :acewindow:WindowNavigation:Frames:Windows:
The ace-window package makes switching between more than two windows
much easier in Emacs. See the documentation for complete details, but
the ace-window command will be bound to M-p here.
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :config
    (progn
      (defalias 'aw 'ace-window)
      (defalias 'transpose-windows 'ace-swap-window)
      (defun ace-window-last ()
        "Change focus to the last window."
        (interactive)
        (aw-switch-to-window (aw--pop-window))))

    :bind (("s-p" . aw)
           ("s-P" . aw) ; To use when M-p is overridden
           ("M-p" . ace-window-last)
           ("M-P" . ace-window-last)))
#+END_SRC
*** TODO Find a way to use S-M-p to alternate between the two most recently used windows
This behavior doesn't seem to be cooked into ace-window by default,
but it would be a real time-saver and convenience. Bonus points if I
can come up with a way to also set the two windows to alternate
between by selecting window numbers in ace-window's numeric window
selection mode.

** helm                                                                :helm:
This package is impossible to categorize completely and deserves its own library
file. See [[*Helm][below]] for the main description.
** Winner Mode                                                  :WindowMgmt:
[[help:winner-mode][Winner Mode]] is a built-in global minor mode for tracking and restoring window
configurations. When enabled, Winner Mode tracks all changes to the dimensions
and positions of windows in an Emacs session's frames, permitting one to cycle
through them using [[help:winner-undo][winner-undo]] and [[help:winner-redo][winner-redo]] commands (by default bound to
=C-c [left]= and =C-c [right]=, respectively). This drastically improves the
amount of time it takes to reset a complicated window configuration after
running a command that shifts windows around.

#+SRC_NAME enable_winner-mode
#+BEGIN_SRC emacs-lisp
  (when (fboundp 'winner-mode)
    (winner-mode))
#+END_SRC
** Frame Commands (frame-cmds)
A comprehensive package for manipulating frames interactively and
programmatically.
#+SRC_NAME frame-cmds_use-package
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package frame-cmds :ensure t)
#+END_SRC
** TRAMP                             :TRAMP:SSH:Tunneling:Remote_Connection:
#+SRC_NAME tramp_use-package
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package tramp
    :config
    (progn
      (defun drmrd/make-sudo-tramp-file-name (name)
        "Return a Tramp file string for opening NAME as root.
  If NAME is itself a Tramp file name (as should be the case for
  remote files), the method component of the corresponding Tramp
  file name object is simply replaced by 'sudo'. (Here by a 'Tramp
  file name object', we mean a Lisp object of the form output by
  `tramp-dissect-file-name'.)  Otherwise (for local files), this
  method prepends the string '/sudo:root@localhost:' to NAME."
        (if (file-remote-p name)
            (let* ((exploded-name (tramp-dissect-file-name name))
                   (old-method (aref exploded-name 0))
                   (old-user (aref exploded-name 1))
                   (old-host (aref exploded-name 2))
                   (old-localname (aref exploded-name 3))
                   (new-hop (format "ssh:%s@%s|" old-user old-host)))
              (tramp-make-tramp-file-name "sudo"
                                          ;; TODO: (2017-05-23) Should this be root or nil?
                                          "root"
                                          old-host
                                          old-localname
                                          new-hop))
          (concat "/sudo:root@localhost:" name)))

      (defun drmrd/sudo-find-alternate-file (name &optional point)
        "Find an alternate file as root.
  Open file FILE in a new buffer, editing it as root, switch to the new
  buffer, move to the point POINT, then kill the old buffer. Compare with
  `find-alternate-file'. If POINT is not provided, the point will remain
  at the beginning of the new buffer."
        ;; MAYBE: (2017-05-22) Make interactive like `find-alternate-file'?
        (find-alternate-file (drmrd/make-sudo-tramp-file-name name))
        (when point (goto-char point)))

      (defun drmrd/edit-as-root ()
        "Edit the current file (or file on this line in dired) as root.
  When in a buffer visitng a file, this command works like
  `find-alternate-file' but reopens the current file as root and
  preserves the point's current position in the file."
        (interactive)
        (let* ((dired-p (equal major-mode 'dired-mode))
               (file (if dired-p (dired-get-file-for-visit) (buffer-file-name)))
               (position (unless dired-p (point))))
          ;; MAYBE: (2017-05-22) Determine reasonable (find-file?) behavior for
          ;;                     a non-dired buffer not visiting a file.
          (when (not (or dired-p file))
            (user-error "%s" "This buffer isn't visiting a file or directory"))
          (drmrd/sudo-find-alternate-file file position)))))
#+END_SRC
** Window Splitting
Most modes will use the function [[help:split-window-preferred-function][split-window-preferred-function]] points to
splitting the current window.  This function is set to [[help:split-window-sensibly][split-window-sensibly]] by
default, which is biased towards splitting the window "vertically", which in
Emacs means splitting the window into two windows one on top of the other (/not/
split them along a vertical line).  This behavior is mostly controlled (for
~split-window-sensible~ at least) by the variables [[help:split-width-threshold][split-width-threshold]] and
[[help:split-height-threshold][split-height-threshold]], and we lower the former to increase the likelihood of
windows splitting horizontally.

#+SRC_NAME window-splitting
#+BEGIN_SRC emacs-lisp :tangle no
  (setq split-width-threshold 1)
  (setq split-height-threshold 1200)

  (defun my-split-window-sensibly (&optional window)
      "Replacement `split-window-sensibly' function which prefers horizontal splits"
      (interactive)
      (let ((window (or window (selected-window))))
          (or (and (window-splittable-p window t)
                   (with-selected-window window
                       (split-window-right)))
              (and (window-splittable-p window)
                   (with-selected-window window
                       (split-window-below))))))

  (setq split-window-preferred-function #'my-split-window-sensibly)



  ;; (setq pop-up-windows t)

  (defun my-display-buffer-function (buf not-this-window)
    (if (and (not pop-up-frames)
             (one-window-p)
             (or not-this-window
                 (not (eq (window-buffer (selected-window)) buf)))
             (> (frame-width) 162))
        (split-window-horizontally))
    ;; Note: Some modules sets `pop-up-windows' to t before calling
    ;; `display-buffer' -- Why, oh, why!
    (let ((display-buffer-function nil)
          (pop-up-windows nil))
      (display-buffer buf not-this-window)))

  (setq display-buffer-function 'my-display-buffer-function)
#+END_SRC

Finer-grained control over window splitting can be accomplished by changing the
value of ~split-window-preferred-function~ to a custom function.

*** Matrix transpose split windows
#+SRC_NAME
#+BEGIN_SRC emacs-lisp
  (require 'windmove)

  (defun transpose-window-split ()
    "Move the next window to the right if it is below or vice versa.

  In other words, if the selected and next window are in a horizontal split
  change it to a vertical split, and do the opposite otherwise."
    (interactive)
    (let ((done))
      (dolist (dirs '((right . down) (down . right)))
        (unless done
          (let* ((win (selected-window))
                 (nextdir (car dirs))
                 (neighbour-dir (cdr dirs))
                 (next-win (windmove-find-other-window nextdir win))
                 (neighbour1 (windmove-find-other-window neighbour-dir win))
                 (neighbour2 (when next-win
                               (with-selected-window next-win
                                 (windmove-find-other-window neighbour-dir next-win)))))
            (setq done (and (eq neighbour1 neighbour2)
                            (not (eq (minibuffer-window) next-win))))
            (if done
                (let* ((other-buf (window-buffer next-win)))
                  (delete-window next-win)
                  (if (eq nextdir 'right)
                      (split-window-vertically)
                    (split-window-horizontally))
                  (set-window-buffer (windmove-find-other-window neighbour-dir) other-buf))))))))


  (defun transpose-window-split-dwim ()
    "Move the next window to the right if it is below or vice versa.

  In other words, if the selected and next window are in a horizontal split
  change it to a vertical split, and do the opposite otherwise. If the selected
  window is the last window in the frame, transpose it and the previous window
  instead."
    (interactive)
    (let* ((at-last-window (eq (next-window) (frame-first-window)))
           (this-window (if at-last-window (previous-window) (selected-window)))
           (other-window (if at-last-window (selected-window) (next-window)))
           (other-window-buffer (window-buffer other-window))
           (direction (let ((window-right-of-this (windmove-find-other-window
                                                   'right this-window)))
                        (if (eq other-window window-right-of-this)
                            'right 'down)))
           (split-fn (if (eq direction 'right)
                         'split-window-vertically
                       'split-window-horizontally)))
      (unless (eq this-window other-window)
        (with-selected-window this-window
          (delete-window other-window)
          (funcall split-fn)
          (set-window-buffer this-window this-window-buffer)
          (set-window-buffer (windmove-find-other-window direction)
                             other-window-buffer)))))

  (global-set-key (kbd "C-x |") 'transpose-window-split)
  (global-set-key (kbd "C-x C-|") 'transpose-window-split)
#+END_SRC
* Search                                                             :Search:
** Enable scrolling in isearch               :isearch:Highlighting:Scrolling:
This allows you to scroll with your mouse in a buffer with an active =isearch=,
preserving highlighting and the location of the current match.
#+SRC_NAME enable_scrolling_in_isearch
#+BEGIN_SRC emacs-lisp
  (setq isearch-allow-scroll t)
#+END_SRC
** Swap roles of C-s and C-M-s, C-r and C-M-r (i.e., regex search by default) :RegEx:Keybindings:
I search via regular expressions frequently, so it only makes sense to make this
the default search method.
#+SRC_NAME prefer_searching_via_regex
#+BEGIN_SRC emacs-lisp
  (bind-key "C-s" 'isearch-forward-regexp)
  (bind-key "C-M-s" 'isearch-forward)

  (bind-key "C-r" 'isearch-backward-regexp)
  (bind-key "C-M-r" 'isearch-backward)
#+END_SRC
** Proximity search (=NEAR= & =AROUND= search operators) :ProximitySearch:AROUND:
Many library/prose-oriented search tools (including Google) make it straight
forward to identify occurrences of two or more phrases in close proximity to one
another. In Google's case, for instance, you can write

#+SRC_NAME AROUND_operator
#+BEGIN_EXAMPLE
  foo AROUND(20) bar
#+END_EXAMPLE

to find webpages containing =foo= and =bar= within 20 words of one another.

The same functionality can be approximated in isearch, swoop, etc. using regular
expressions like

#+SRC_NAME AROUND_regex
#+BEGIN_EXAMPLE
  \<foo\>\W\(\w+\W+\)\{,20\}\<bar\>\|\<bar\>\W\(\w+\W+\)\{,20\}\<foo\>
#+END_EXAMPLE

but this isn't exactly convenient to type out in the middle of another task. So
we provide a couple functions for it!

#+SRC_NAME proximity_search_functions
#+BEGIN_SRC emacs-lisp
  (defun proximity-search ()
    "Find all occurrences of two words at most a given number of words apart."
    ;; TODO: Update to support arbitrary numbers of words. That algorithm is much
    ;; more interesting!
    (interactive)
    (let ((word1 (read-string "First word:"))
          (word2 (read-string "Second word:"))
          (word-distance (read-number "Distance:" 1)))
      (occur (concat "\\<"
                     word1 "\\>\\(\\W\\<\\w+\\>\\)\\{,"
                     (number-to-string word-distance) "\\}\\W+\\<" word2 "\\>\\|\\<"
                     word2 "\\>\\(\\W+\\<\\w+\\>\\)\\{,"
                     (number-to-string word-distance) "\\}\\W+\\<" word1 "\\>"))))

  (defalias 'proximity-word-search 'proximity-search)
  (defalias 'near-search 'proximity-search)
  (defalias 'near-word-search 'proximity-search)
#+END_SRC

Reference: https://www.emacswiki.org/emacs/SearchNear
* General Settings
** Personal Information                                           :Personal:
*** Name & Email Address                           :Name:Email:ContactInfo:
If the full name you provided to your current operating system (/e.g./, as part
of creating your user account) differs from the one you'd like Emacs (and most
of its packages) to use when personalizing contents for you, set the
=user-full-name= variable to whatever you'd prefer to see. I do this for
consistency and to ensure that everything is consistent on shared computers.

#+SRC_NAME: set_name_and_email_address_variables
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Dan Moore")
  (setq user-mail-address "hello@danielmoore.xyz")

  ;; For ChangeLogs...
  (setq add-log-full-name "Daniel R. Moore")
  (setq add-log-mailing-address "changes@danielmoore.xyz")
#+END_SRC
*** TODO Paradox GitHub Token                              :GitHub:Secrets:
One of the cooler features of the [[help:paradox-menu-mode][Paradox package manager]] is its ability to star
and unstar GitHub repositories for packages as you browse. Enabling this
requires providing Paradox an access token for your GitHub account, the setup
process for which you're guided through after initially installing the
package. (You can also refer to the documentation of the [[help:paradox-github-token][paradox-github-token]]
(the variable wherein the token is stored) for more information.

The following code loads a file containing a single instruction, which sets
the =paradox-github-token= to the token value. I store it in my =secure=
subdirectory, which is not a part of this repository to avoid sharing it with
the world. You should always avoid storing access tokens in a public place.
#+BEGIN_SRC emacs-lisp :tangle no
  (org-babel-load-file
      (expand-file-name "~/.emacs.d/secure/paradox-github-token.org"))
#+END_SRC
** Default Keybinding Replacements                              :Keybindings:
#+BEGIN_SRC emacs-lisp
  (bind-key "M-/" 'hippie-expand)
  (bind-key "M-S-z" 'zap-up-to-char)

  (bind-key "M-!" 'eshell-command)

  (setq select-enable-clipboard             t
        select-enable-primary               t
        save-interprogram-paste-before-kill t
        mouse-yank-at-point                 t)
#+END_SRC
** General Editing Settings
*** Fill Column Settings
#+SRC_NAME set-fill-column
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;; Make fill-column default to 80 (instead of the usual 70)
  (setq-default fill-column 80)
#+END_SRC

#+SRC_NAME enable_fill_column_indicators
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;; Display a vertical rule at the fill-column
  (use-package fill-column-indicator
      :config (turn-on-fci-mode))
#+END_SRC
*** Increase Kill Ring Size                                 :Helm:KillRing:
Since we are using helm, the fact that the kill ring is a ring has become less
relevant, and it makes sense to ratchet up the maximum number of killed pieces
of text to store there.
#+SRC_NAME set_max_kill-ring_size
#+BEGIN_SRC emacs-lisp
  (setq kill-ring-max 1000)
#+END_SRC
** TODO What to Display at Startup
Disable the welcome screen and instead display a welcome message as a
comment in the scratch buffer.
#+BEGIN_SRC emacs-lisp :tangle no
  (setq inhibit-startup-screen t)   ; Disable Emacs's welcome screen
  (use-package fortune-cookie :ensure t
    :init (setq fortune-cookie-cowsay-enable nil)
    :config (fortune-cookie-mode))
#+END_SRC
** Change Where Customizations are Stored                   :Customizations:
By default, Emacs adds settings set via the customizations menu to the
end of the .emacs file.
#+SRC_NAME set_customizations_file
#+BEGIN_SRC emacs-lisp
  (defconst custom-file (expand-file-name "customizations.el" user-emacs-directory))

  ;; Setting NOERROR to non-nil to make Emacs create `custom-file' if it doesn't
  ;; exist rather than raise an error.
  (load custom-file t)
#+END_SRC

** Load Third-Party Elisp not Managed by *Package*
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/elisp")
#+END_SRC
** Bind Settings Files to Registers                            :Keybindings:
Bind main.org, .emacs.d/lib/latex.org, and Preferences.el to the
registers "e", "l", and "p" (resp.) so that they can be opened easily with
"C-x r j <register>".

#+SRC_NAME set-config-registers
#+BEGIN_SRC emacs-lisp
  (set-register ?e '(file . "~/.emacs.d/main.org"))
  (set-register ?h '(file . "~/.emacs.d/lib/helm.org"))
  (set-register ?i '(file . "~/.emacs.d/init.el"))
  (set-register ?l '(file . "~/.emacs.d/lib/latex.org"))
  (set-register ?o '(file . "~/.emacs.d/lib/org.org"))
  (set-register ?L '(file . "~/.emacs.d/lib/"))
  (set-register ?W '(file . "~/workspace/"))
#+END_SRC

*** DONE Determine how to evaluate this file without reloading Aquamacs
Invoke org-babel-load-file on main.org to retangle and reload this
file.

To modify and re-evaluate a single code block, use C-c C-c inside the block.
*** DONE Add registers for .emacs.d/lib/latex.org and Preferences.el
It might be worth also adding a register for Preferences.el for when I
want to evaluate this buffer without reloading emacs (although Babel
probably has an easier way to do that natively).
** Set the Default Directory
Make the default directory ~/workspace/ for easy access to LaTeX
projects.

#+BEGIN_SRC emacs-lisp
  (setq default-directory "~/workspace/")
#+END_SRC

** Set the Default Major Mode to Text Mode
Make Text Mode the default major mode, but disable the Auto-Fill Mode
hook.

#+BEGIN_SRC emacs-lisp
  (setq default-major-mode 'text-mode)
  (remove-hook 'text-mode-hook 'auto-fill-mode)
  (add-hook 'text-mode-hook 'kill-auto-fill-mode)
#+END_SRC

** Make Emacs insert a newline at the end of each file
I can't find a link at the moment, but requiring newlines at the end
of files prevents some kind of buggy behavior at times. I think I read
about this on StackExchange at some point.

#+BEGIN_SRC emacs-lisp
  (setq require-final-newline t)
#+END_SRC
** Backup Settings                                                 :Backups:
#+BEGIN_SRC emacs-lisp
  ;; Store all backup files created by Emacs in the same directory
  (setq backup-directory-alist '(("." . "~/.backups_emacs")))

  ;; Make Emacs create backups by copying files. If this leads to a performance
  ;; hit, see the other available backup methods (or just comment out this line),
  ;; as described in the documentation of the make-backup-files variable.
  (setq backup-by-copying t)

  (setq delete-old-versions t
        kept-new-versions   6
        kept-old-versions   2
        version-control     t) ; Use version numbers in backup file names
#+END_SRC
** (DISABLED) Force Files to Open in Read Only Mode
This is a bit of an experiment to see if I like defaulting to this
behavior, but I'd rather have to actively switch to editing
dissertation files than accidentally make changes when I'm just
browsing. Uhoh...this might be a slippery slope towards using evil
mode, I think. As usual, if selecting from dired I can just use =v=
(bound by default to [[help:dired-view-file][dired-view-file]]. When loading from the
minibuffer, the easiest solution is just adding a function that sets
the buffer to read only to the [[help:find-file-hook][find-file-hook]].

#+SRC_NAME: force-read-only-buffers
#+BEGIN_SRC emacs-lisp :tangle no
  (add-hook 'find-file-hook (lambda () (setq buffer-read-only t)))
#+END_SRC

A better solution is to probably set buffer-read-only to true as a
file variable when needed.

*Edit:* This has been disabled, since, as I suspected, it breaks
 everything.
** Other Default Settings
#+BEGIN_SRC emacs-lisp
  (setq apropos-do-all t)   ; Make all apropos commands perform more
                            ; extensive searches

  ;; Make y and n suffice for answers to yes or no questions
  (fset 'yes-or-no-p 'y-or-n-p)

  ;; MAYBE: (2017-06-04) Create a custom predicate function that's more
  ;;                     fine-grained.

  ;; Make Emacs confirm when you kill it.  If you've ever fat fingered C-x C-[...]
  ;; commands as C-x C-w [...], you know why this is here.
  (setq confirm-kill-emacs 'y-or-n-p)
#+END_SRC
** Enable "Advanced" Commands
Here I'm reinstating a number of incredibly useful commands to their rightful
keybindings that are disabled by default in Emacs to avoid confusing newcomers.
#+SRC_NAME re-enable_advanced_commands
#+BEGIN_SRC emacs-lisp
  (cl-dolist (disabled-function '(dired-find-alternate-file
                                  downcase-region
                                  erase-buffer
                                  Info-edit
                                  narrow-to-page
                                  narrow-to-region
                                  scroll-left
                                  set-goal-column
                                  upcase-region))
    (put disabled-function 'disabled nil))
#+END_SRC
** Compilation Behavior                               :Keybindings:Compiling:
The following is brought to us by bpalmer and zigler on the [[https://www.emacswiki.org/emacs/UsingMakefileFromParentDirectory][EmacsWiki]]. It adds a
=get-nearest-compilation-file= function that searches parent directories for a
Makefile (or any file with name in =compilation-filenames=) to use during
compilation and binds the new function to F5.
#+BEGIN_SRC emacs-lisp
  (setq compilation-filenames '("Makefile"))

  (defun get-nearest-compilation-file ()
    "Search for the compilation file traversing up the directory tree."
    (let ((dir default-directory)
          (parent-dir (file-name-directory (directory-file-name default-directory)))
          (nearest-compilation-file 'nil))
      (while (and (not (string= dir parent-dir))
                  (not nearest-compilation-file))
        (cl-dolist (filename compilation-filenames)
          (setq file-path (concat dir filename))
          (when (file-readable-p file-path)
            (setq nearest-compilation-file file-path)))
        (setq dir parent-dir
              parent-dir (file-name-directory (directory-file-name parent-dir))))
      nearest-compilation-file))

  ;; Bind compiling with get-nearest-compilation-file to F5.
  (global-set-key
   [f5]
   (lambda ()
     (interactive)
     (compile (format "make -f %s" (get-nearest-compilation-file)))))
#+END_SRC
** Indentation & Whitespace Settings
This deserves its own section, since it is always the part of text
editors I tweak the most.
*** Default to indenting with spaces, four at a time
#+BEGIN_SRC emacs-lisp
  ;; make return key also do indent, globally
  ; (electric-indent-mode 1)

  ;; Set tab width to 4
  (setq tab-stop-list (number-sequence 4 200 4))

  ;; Force emacs to only indent with spaces and never tabs
  (setq-default indent-tabs-mode nil)
#+END_SRC
*** [Tab] behavior
**** Set =tab-always=indent=: Make [Tab] try to indent or (if already indented) complete the thing-at-point
Change the =tab-always-indent= setting to "complete", which makes
[Tab] first try to indent the current line and then, iff it was
already indented, attempt to complete the thing at the current point.

The other options for this variable are =nil=, which makes [Tab]
indent the current line if at the left margin or in its indentation
and otherwise literally insert a TAB character, and =t=, which makes
[Tab] always indent.
#+BEGIN_SRC emacs-lisp
  (setq-default tab-always-indent 'complete)
#+END_SRC emacs-lisp

**** Bind M-q to =indent-relative=
#+BEGIN_SRC emacs-lisp
  ;;
  ;  Makes M-q indent from cursor to the space prior to the next
  ;  non-whitespace character on the previous line.
  ;
  ;  Example: If the current buffer looks as follows (with the cursor denoted by *)...
  ;
  ;          sample text is entertaining to write
  ;          I completely agree* with you
  ;
  ;      Then the result of hitting M-q will be
  ;
  ;          sample text is entertaining to write
  ;          I completely agree          with you
  ;
  ;      with the cursor right before the "w" in "with".
  (global-set-key (kbd "M-q") 'indent-relative)
#+END_SRC
***** TODO Consider also setting [Tab] (or something) to (indent-relative-maybe).

* IDE Features                                      :IDE:Convenience:Editing:
** CEDET, Semantic, SRefactor, & ECB          :CEDET:Semantic:SRefactor:ECB:
#+SRC_NAME semantic_setup
#+BEGIN_SRC emacs-lisp
  (use-package semantic
    :defer t
    :config
      (global-semantic-idle-scheduler-mode 1)
      (global-semantic-stickyfunc-mode 1)
      (global-semanticdb-minor-mode 1))
#+END_SRC

#+SRC_NAME srefactor_setup
#+BEGIN_SRC emacs-lisp
  (use-package srefactor
    :ensure t
    :defer t
    :config (semantic-mode 1))
#+END_SRC

*** TODO ECB                                                          :ECB:
Loading ECB (the Emacs Code Browser) seems to fail with my current setup, so
I've disabled it for the time being. Might be worth finding a fix in the
future.
#+SRC_NAME ecb_setup
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ecb
    :defer t
    :init
      (semantic-mode 1)
      (setq stack-trace-on-error t))
#+END_SRC
** flycheck & friends: On-the-fly error checking & linting :Lint:ErrorChecking:flycheck:
#+SRC_NAME enable_global-flycheck-mode
#+BEGIN_SRC emacs-lisp
  ;;; Flycheck Mode (and friends)
  ;;;
  ;;;     Enable and configure `flycheck' for a powerful, customizable,
  ;;;     extensible, drop-in replacement for `flymake'.

  ;; Load flycheck
  (use-package flycheck
      :ensure t
      :init (global-flycheck-mode))
#+END_SRC

#+SRC_NAME enable_flycheck_extensions
#+BEGIN_SRC emacs-lisp
  ;; Change the color of the modeline based on flycheck's current status
  (use-package flycheck-color-mode-line
      :ensure t
      :after flycheck
      :config (add-hook 'flycheck-mode-hook 'flycheck-color-mode-line-mode))

  ;; Display a tooltip at the cursor position when on a flycheck error
  (use-package flycheck-pos-tip
      :ensure t
      :after flycheck
      :if window-system
      :config (add-hook 'flycheck-mode-hook 'flycheck-pos-tip-mode))

  ;; Replace `flycheck''s built-in modeline status indicators with cute, compact,
  ;; meaningful emoji and warning/error counts
  (use-package flycheck-status-emoji
      :ensure t
      :after flycheck
      :init (set-fontset-font t nil "Symbola")
      :config (add-hook 'flycheck-mode-hook 'flycheck-status-emoji-mode))

  ;; Support adding C/C++ libraries to `flycheck-clang-include-path' using
  ;; `pkg-config' and completion. This simplifies getting `flycheck' to recognize
  ;; appropriate libraries in a system-independent way.
  ;;
  ;; Note: This is not a minor mode. Call `flycheck-pkg-config' interactively to
  ;; lookup (with completion) the correct path to add to
  ;; `flycheck-clang-include-path' by library name.
  (use-package flycheck-pkg-config
    :ensure t
    :after flycheck)
#+END_SRC
** STARTED Projectile: PROJECT Interaction Library for Emacs :ProjectManagement:projectile:
#+SRC_NAME load_projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile :ensure t
    :config (projectile-global-mode))
#+END_SRC

* Utility Functions                                               :Functions:
** drmrd/load-library
#+SRC_NAME: def_drmrd/load-library
#+BEGIN_SRC emacs-lisp
  (defun drmrd/load-library (name &optional directory)
    "Load the library NAME in the default library. Here NAME can be any
    file name or relative path to a file, but it should be relative to the default
    library directory specified in the `drmrd/lib-directory' variable, unless an
    alternative directory DIRECTORY is given as a second argument. This function
    can not be called interactively."
    (org-babel-load-file (expand-file-name name (or directory
                                                    drmrd/lib-directory))))
#+END_SRC
** TODO Testing things exist                          :drmrd_shell_commandp:
This needs to be fixed and DRYed up
#+SRC_NAME drmrd/shell-commandp_defun :tangle no
#+BEGIN_SRC emacs-lisp
  (defun drmrd/shell-commandp (command &optional test-command-and-failure-check)
    "Determine whether a shell COMMAND is known to the default shell.

  No attempt is made to ensure COMMAND isn't an alias.  It uses the current user's
  default or whatever shell is pointed to by `shell-file-name'.  It tries to
  intelligently choose between using a 'type' or 'whence' built-in for testing
  based on the current shell, but its choice can be overridden and an explicit
  test command to pass COMMAND into (as a suffix) and a function to test the
  output can be set by providing the optional TEST-COMMAND-AND-FAILURE-CHECK
  parameter."
    (let* '((shell-name (file-name-nondirectory shell-file-name))
            (test-command
             (or test-command-and-failure-check
                 (cond ((or (string-equal shell-name "zsh")
                            (string-equal shell-name "ksh"))
                        (cons "whence -w "
                              (lambda (output)
                                (string-equal output (concat command ": none")))))
                       ((or (string-equal shell-name "sh")
                            (string-equal shell-name "bash")
                            (string-equal shell-name "fish"))
                        (cons "type -t "
                              (lambda (output)
                                (eq (length output) 0))))
                       (t (error "Unknown shell '%s'" shell-name)))))
            (test-output (substring
                          (shell-command-to-string
                           (concat (car test-command-and-failure-check) command))
                          0 -1)))
      (funcall (cdr test-command-and-failure-check) test-output)))
#+END_SRC
** insert-to-last-eol
#+BEGIN_SRC emacs-lisp
  (defun get-beginning-of-line-position (&optional arg)
    "Return the position of the beginning of the current line as
  displayed. (If there's an image in the line containing newlines, the
  same rules apply for this function as for `move-beginning-of-line'.)

  If an argument ARG is provided, return the position at the beginning
  of the (ARG - 1)-th line after (forward from) the current one. If ARG
  refers to a line before the first (respectively, after the last),
  return the position at the beginning of the first (respectively, last)
  line in this buffer."
    ;; It doesn't mention this in its docstring (like most point
    ;; manipulation functions), but `move-beginning-of-line' returns the
    ;; point it moves to after executing. So we just have to prevent it
    ;; from actually affecting the buffer position.
    (save-excursion (move-beginning-of-line arg)))

  (defun get-end-of-line-position (&optional arg)
    "Return the position of the end of the current line as
  displayed. (If there's an image in the line containing newlines,
  the same rules apply for this function as for
  `move-end-of-line'.)

  If an argument ARG is provided, return the position at the end of
  the (ARG - 1)-th line after (forward from) the current one. If
  ARG refers to a line before the first (respectively, after the
  last), return the position at the end of the first (respectively,
  last) line in this buffer."
    ;; It doesn't mention this in its docstring (like most point
    ;; manipulation functions), but `move-end-of-line' returns the point
    ;; it moves to after executing. So we just have to prevent it from
    ;; actually affecting the buffer position.
    (save-excursion (move-end-of-line arg)))

  (defun get-line-length (&optional arg)
    "Return the length of the current line as displayed (excluding
  invisible text, for instance). (If there's an image in the line
  containing newlines, the same rules apply for this function as for
  the `move-beginning-of-line' and `move-end-of-line' commands.)

  If an argument ARG is provided, return the length of the (ARG - 1)-th
  line after (forward from) the current one. If ARG refers to a line
  before the first (respectively, after the last), return the length of
  the first (respectively, last) line in this buffer."
    (- (line-end-position arg)
       (line-beginning-position arg)))

  ;; TODO: These are already defined by `line-beginning-position' and
  ;; `line-end-position'. Use `defalias' and these commands instead to
  ;; define the above functions. ...wasn't aware of these functions when
  ;; I first wrote these...

  ;; TODO: Consider prompting for input characters/strings in the next function
  (defun insert-to-previous-eol (&optional input)
    "Repeatedly insert the character before the point until in the
  column where the previous line ends. An error is thrown if the
  point is at the beginning of a line or if it is in the first line
  of the buffer."
    (interactive)
    ;; Throw an error if no `CHAR' is provided and the point is at
    ;; the beginning of a line.
    (when (= (line-beginning-position) (point))
      ;; FIXME: Determine if there's a better way to break the error
      ;;        string onto multiple lines that still looks
      ;;        stylistically correct.
      (error (concat "Error: No argument provided and point is at the "
                     "beginning of a line.")))
    ;; Also throw an error if the point is on the first line.
    (when (= (get-beginning-of-line-position 0)
             (get-beginning-of-line-position 1))
      (error (concat "Error: The point is on the first line of the "
                     "current buffer.")))
    (insert-char (char-before)
                 (- (get-line-length 0)
                    (- (point) (get-beginning-of-line-position 1)))))
#+END_SRC
** copy-regex: Copy Regular Expression without Doubling Backslashes
Yank text into the minibuffer without backslashes being doubled. This
is especially useful when working with regular expressions.

#+BEGIN_SRC emacs-lisp
  (defun copy-regex ()
    "Copy current RE into the kill ring without quotes and single
  backslashes for later insertion. This can be thought of as a drop-in
  replacement for `reb-copy' when you wish to yank the resulting copied
  regular expression from the kill ring into a minibuffer (as opposed to
  into elisp code somewhere."
    (interactive)
    (reb-update-regexp)
    (let* ((re (with-output-to-string (print (reb-target-binding reb-regexp))))
           (str (substring re 2 (- (length re) 2))))
      (with-temp-buffer (insert str)
                        (goto-char (point-min))
                        (while (search-forward "\\\\" nil t)
                          (replace-match "\\" nil t))
                        (kill-new (buffer-substring (point-min) (point-max))))
      (message "Regexp copied to kill-ring")))
#+END_SRC
** kill-auto-fill-mode: Disable auto-fill-mode (use as a hook) :Aquamacs:macOS:
#+BEGIN_SRC emacs-lisp
  (defun kill-auto-fill-mode ()
         "Disables auto-fill-mode when used as a hook"
         (auto-fill-mode -1)
         ; Remove the auto-detect-wrap function from the
         ; text-mode-hook if on Mac OS X (in case you're running
         ; Aquamacs).
         (when (eq system-type 'darwin)
           (remove-hook 'text-mode-hook 'auto-detect-wrap)))
#+END_SRC
** kill-aquamacs-autoface-mode: Disable aquamacs-autoface-mode (use as a hook) :Aquamacs:macOS:
#+BEGIN_SRC emacs-lisp
  (defun kill-aquamacs-autoface-mode ()
    "Disables Aquamacs's built-in `aquamacs-autoface-mode' when used as a hook."
    (if (eq system-type 'darwin)
        (progn (aquamacs-autoface-mode -1)
               (message "Aquamacs Autoface Mode disabled"))))
#+END_SRC
** org-babel-reload-file: org-babel-load-file but defaulting to the current file
#+BEGIN_SRC emacs-lisp
  (defun org-babel-reload-file (file &optional compile)
    "Tangle and load a specified file, with the current buffer's file as
    default.

    Tangle the Emacs Lisp source code in the indicated Org-mode file
    FILE or the file corresponding to the active buffer if FILE is nil
    and the current buffer corresponds to an existing file. This works
    in precisely the same way as `org-babel-load-file'--calling
    `org-babel-tangle' on FILE and then `load-file' on the output elisp
    file--with the only difference being that this function defaults to
    the current file if no argument is provided."
    (interactive (let* ((buffer (buffer-file-name (current-buffer)))
                         prompt)
                       (setq prompt (format "File to load%s: "
                                            (if buffer
                                                (format " [Default: %s]" buffer))))
                       (list (read-file-name prompt nil (if buffer buffer)))))
    (org-babel-load-file file compile))
#+END_SRC

*** DONE Finish implementing this function
CLOSED: [2015-12-05 Sat 12:54]
*** DONE Make the interactive prompt string say "default: [current buffer name here]"
CLOSED: [2015-12-05 Sat 12:55]

** string-length: Get the length of a string you input in a buffer (or have selected)
The built-in function [[help:string-width][string-width]] is made for exactly this purpose,
but it's not interactive (and, hence, can't be called for this
purpose). So this is just a wrapper function.
#+BEGIN_SRC emacs-lisp
  (defun string-length (string)
    "Get the length of a string input in the minibuffer."
    (interactive "^sString: ")
    (message (number-to-string (string-width string))))
#+END_SRC
** day-ordinal: Add ordinals to the current day of the month and a new format specifier %o
Provide support for displaying the current day's ordinal in
format-time-string calls without overriding anything.

#+BEGIN_SRC emacs-lisp
  (defun ordinal (n)
    "Special day of month format."
    (format
     (concat
      "%d"
      (if (memq n '(11 12 13)) "th"
        (let ((last-digit (% n 10)))
          (cl-case last-digit
            (1 "st")
            (2 "nd")
            (3 "rd")
            (otherwise "th"))))) n))

  (defadvice format-time-string (before ordinal activate)
    "Add ordinal to %d."
    (let ((day (nth 3 (decode-time (or time (current-time))))))
      (setq format-string
        (replace-regexp-in-string "%o"
                      (ordinal day)
                      format-string))))
#+END_SRC
** today-is: Get today's date
#+BEGIN_SRC emacs-lisp
  (defun today-is ()
    "Displays the current date."
    (interactive)
    (message (format-time-string "Today is %A, %B %o, %Y")))
#+END_SRC
** insert-date, insert-time, and insert-date-and-time
These functions wear their hearts on their sleeves...not much more to
say about them.
#+SRC_NAME def_insert-date-and-time
#+BEGIN_SRC emacs-lisp
  ;;; Insert the date, time, or both at the current point
  (defun insert-date-and-time (&optional format-string)
    "Interactively insert the current date and time into the buffer at
  the point. The optional `format-string' argument accepts the same
  format as `format-time-string', and it defaults to '%F at %r', which
  creates dates and times such as '2016-07-04 at 06:49:17 PM'."
    (interactive)
    ;; Note the default format is equivalent to "%Y-%m-%d at %I:%M:%S %p"
    (insert (format-time-string (or format-string "%F at %r"))))

  (defun insert-date (&optional format-string)
    "Interactively insert the current date into the buffer at the
  point. The optional `format-string' argument accepts the same format
  as `format-time-string', and it defaults to '%F', which creates dates
  such as '2016-07-04'."
    (interactive)
    (insert-date-and-time (or format-string "%F")))

  (defun insert-time (&optional format-string)
    "Interactively insert the current time into the buffer at the
  point. The optional `format-string' argument accepts the same format
  as `format-time-string', and it defaults to '%r', which creates times
  such as '12:27:52 AM'."
    (interactive)
    (insert-date-and-time (or format-string "%r")))
#+END_SRC
** insert-random-UUID
#+NAME: insert-random-uuid
#+BEGIN_SRC emacs-lisp
    (defun insert-random-uuid ()
           "Inserts a UUID into the buffer at the current point. The UUID is
           generated using Linux's built-in uuidgen command."
           (interactive)
           (shell-command "uuidgen" t))
#+END_SRC
*** TODO Throw an error if not on Linux
* Programming Languages                                                :Lang:
** Ansible                                                         :Ansible:
#+SRC_NAME configure_ansible_packages
#+BEGIN_SRC emacs-lisp
  (use-package ansible :ensure t)
  (use-package ansible-vault :ensure t)
#+END_SRC
** JSON                                                               :JSON:
#+SRC_NAME json-mode_use-package
#+BEGIN_SRC emacs-lisp
  (use-package json-mode :ensure t)
#+END_SRC
** TODO Jenkins                                                    :Jenkins:
*** TODO Consider using this Jenkins plugin for monitoring /within/ Emacs
See [[https://github.com/rmuslimov/jenkins.el][this GitHub repo]].
** Java                                                     :Java:meghanada:
#+SRC_NAME meghanada_use-package
#+BEGIN_SRC emacs-lisp
  ;; (use-package meghanada :ensure t
  ;;   :config
  ;;     (add-hook 'java-mode-hook
  ;;               (lambda ()
  ;;                 ;; meghanada-mode on
  ;;                 (meghanada-mode)
  ;;                 (add-hook 'before-save-hook
  ;;                           'meghanada-code-beautify-before-save))))
#+END_SRC
** Groovy & Gradle                                 :Groovy:Gradle:meghanada:
#+SRC_NAME groovy_setup
#+BEGIN_SRC emacs-lisp
  (use-package groovy-mode
    :ensure    t
    :defer     t
    :init (add-hook 'groovy-mode-hook
                    (lambda ()
                      (c-set-offset 'label 4)))
          ;; (add-hook 'groovy-mode-hook
          ;;           (lambda ()
          ;;             ;; meghanada-mode on
          ;;             (meghanada-mode)
          ;;             (add-hook 'before-save-hook
          ;;                       'meghanada-code-beautify-before-save)))
    :mode ("\\(Jenkinsfile\\|\\.\\(groovy\\|gradle\\)\\)$" . groovy-mode))
#+END_SRC
** TODO Spock                                                        :Spock:
** Grails                                                :Grails:Projectile:
#+SRC_NAME grails-projectile-mode_use-package
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package grails-projectile-mode
    :diminish  grails-projectile-mode)
#+END_SRC
** XML                                                                 :XML:
We can use the built-in =nxml-mode= for viewing XML files, so we can configure
XML mode without use-package
#+SRC_NAME nxml-mode_setup
#+BEGIN_SRC emacs-lisp
  (use-package nxml
    :init      (setq nxml-slash-auto-complete-flag t
                     ;; nxml-child-indent             ers-tab-size
                     ;; nxml-outline-child-indent     ers-tab-size
                     )
    :defer     t
    :mode      ("\\.\\(pom\\|xsd\\|xsl\\|xslt\\|gsp\\)$" . nxml-mode))
#+END_SRC
** YAML
#+SRC_NAME yaml-mode_use-package
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode :ensure t)
#+END_SRC
** TODO Maven                                                   :Maven:Java:
See [[https://github.com/Fuco1/.emacs.d/blob/master/files/vendor.el][this init file]] for a /comprehensive/ configuration of =malabar-mode= (a mode
for Java that boasts [[https://www.emacswiki.org/emacs/MalabarMode]["tight integration with Maven"]].
** Shell                                                             :Shell:
The only shell scripts I use that Emacs doesn't handle well by default are
Windows batch files (although I can't remember the last time I was on Windows
long enough to edit one of those) and Fish scripts. We also need to make
[[help:shell-script-mode][shell-script-mode]] (a.k.a. [[help:sh-mode][sh-mode]] (not a.k.a. [[help:shell-mode][shell-mode]] (confusingly))) aware
that =.zsh= files are a thing

#+SRC_NAME batch-mode_use-package
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package batch-mode :ensure t
    :mode ("\\.\\(bat\\)$" . batch-mode))
#+END_SRC

#+SRC_NAME fish-mode_use-package
#+BEGIN_SRC  emacs-lisp
  (use-package fish-mode :ensure t
    :mode ("\\.\\(fish\\)$" . fish-mode))
#+END_SRC

#+SRC_NAME sh-mode_config
#+BEGIN_SRC emacs-lisp
  (setq-default sh-learn-basic-offset 'good-guess
                sh-indentation        4)
#+END_SRC
** TODO Cucumber                                 :Cucumber:IntegrationTests:
** Ruby, Rake, RBENV, Rspec
#+SRC_NAME setup_ruby_packages
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package rake :ensure t)
  (use-package rbenv :ensure t)
  (use-package rspec-mode :ensure t
    :config (add-hook 'dired-mode-hook 'rspec-dired-mode))
  (use-package web-mode :ensure t)
  ;; (use-package robe :ensure t)
#+END_SRC
** CoffeeScript
#+SRC_NAME setup_coffeescript_packages
#+BEGIN_SRC emacs-lisp
  (use-package coffee-mode :ensure t)
#+END_SRC
** TODO Lisp
#+SRC_NAME setup_lisp_packages
#+BEGIN_SRC emacs-lisp
  (use-package apiwrap :ensure t)
#+END_SRC
*** TODO Determine if this deserves its own top-level header (or is better placed elsewhere)
** Dockerfiles                                           :Docker:Dockerfile:
#+SRC_NAME dockerfile-mode_use-package
#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode :ensure t)
#+END_SRC
** Terraform                                           :Terraform:Hashicorp:
#+SRC_NAME terraform-mode_use-package
#+BEGIN_SRC emacs-lisp
  (use-package hcl-mode :ensure t)
  (use-package terraform-mode :ensure t)
#+END_SRC
** Jinja2                                :Jinja2:Python:TemplatingLanguages:
#+SRC_NAME jinja2-mode_use-package
#+BEGIN_SRC emacs-lisp
  (use-package jinja2-mode :ensure t)
#+END_SRC
** Clojure                                                   :Clojure:CIDER:
#+SRC_NAME clojure-mode_use-package
#+BEGIN_SRC emacs-lisp
  (use-package clojure-mode :ensure t)
  (use-package cider :ensure t)
#+END_SRC
** Scala                                                      :Scala:ENSIME:
The /de facto/ standard for working with Scala in Emacs is through the ENSIME
(ENhanced Scala Interaction Mode for Emacs ) package.
#+SRC_NAME scala_ensime_use-package
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ensime :ensure t :pin melpa-stable)
#+END_SRC
* Misc. Packages                                                   :Packages:
The following list comprises all of the packages that (a) are loaded by default
in most major modes and (b) don't fit elsewhere in this configuration (yet).
** discover                                                       :discover:
A relatively new kid on the block for learning some of Emacs's more obscure
switches through Magit-style context menus. See the [[obscurehttps://www.masteringemacs.org/article/discoverel-discover-emacs-context-menus][Mastering Emacs]] article for
more information. It's currently enabled for registers (=C-x r=), dired mode
(=?=), and isearch (=M-s=).
#+SRC_NAME discover_use-package
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package discover :init (global-discover-mode 1))
#+END_SRC
** fasd                                              :emacs_fasd:find_files:
#+SRC_NAME fasd_use-package
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package fasd :ensure t
    ;; TODO: (2017-11-19) ":if (shell-command-p "fasd")"
    ;;                    or ":if (package-installed-p \"fasd\")"
    :config (global-fasd-mode 1)
    :bind ("C-x C-/" . fasd-find-file))

  (use-github-package helm-fasd "madper/helm-fasd"
      :bind (("C-x /" . helm-fasd)
             ("C-c h F" . helm-fasd)))
#+END_SRC
** fixmee                                :fixmee:TaskManagement:Navigation:
A package for displaying and navigating TODOs, FIXMEs, etc. throughout a
project. Works great with =projectile=, too! Use the =C-x f= keybinding to load
a =projectile + fixmee= [[hydra]].

Tags are case-insensitive except for XXX, and priority (used in
priority-based navigation) is increased by adding more of the last
letter to the end of a tag. (For example FIXMEEEE has higher priority
than FIXME.)

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package button-lock
    :ensure t
    :config
      (global-button-lock-mode 1))

  (use-package wiki-nav
    :config
      (global-wiki-nav-mode 1))

  (use-package fixmee
    :after wiki-nav
    :init
      (require 'button-lock)

      (defun drmrd/car-or-self-safe (object)
        "Return the car of OBJECT if it has one and OBJECT otherwise.  This
  functionality should be considered complementary to the `car-safe' function."
        (if (consp object) (car object) object))

      (defun drmrd/coerce-to-string (object)
        "Attempt to convert OBJECT to a string.  For the time being, this function
  will convert any character, string, or symbol to a string with no guarantee of
  success when OBJECT is of another form."
        (cond ((symbolp object) (symbol-name object))
              (t (coerce object 'string))))

      (defun drmrd/regexp-matching-char-case-insensitively (char)
        "Convert the character CHAR to a regular expression in string form that
  matches one occurrence of CHAR case insensitively.  For example, if CHAR is the
  lowercase letter 'a', then the output of this function is the string \"[aA]\".
  If CHAR is not a character with lowercase and uppercase forms recognized by
  `downcase' and `upcase', this simply returns CHAR as a string."
        (unless (characterp char)
          (error "The provided argument is not a character: %s" char))
        (let* ((char-as-string (string char))
               (lowercase-char (downcase char-as-string))
               (uppercase-char (upcase char-as-string)))
          (if (equal lowercase-char uppercase-char)
              char-as-string
            (concat "[" lowercase-char uppercase-char "]"))))

      (defun drmrd/words-to-fixmees (&rest tags)
        "Convert a list of words indicating comment flags to a format
  `fixmee-mode' understands.  The TAGS should consist of strings, symbols (to be
  converted to strings), and pairs of the form (STRING-OR-SYMBOL
  CASE-SENSITIVE-P), where STRING-OR-SYMBOL is either a string or a symbol to be
  recognized by fixmee as a fixmee flag and CASE-SENSITIVE-P indicates whether or
  not STRING-OR-SYMBOL should be considered case-sensitive.

  This function does not check whether or not its arguments can be converted into
  valid tags for fixmee comments.  Please read the help page for
  `fixmee-notice-regexp' to see which strings are permissible."

        (let* ((fixmee-tag-spec (first tags))
               (fixmee-tag (drmrd/coerce-to-string
                            (drmrd/car-or-self-safe fixmee-tag-spec)))
               (case-sensitive-p (cdr-safe fixmee-tag-spec))
               (fixmee-string
                (concatenate
                 'string
                 (if case-sensitive-p
                     fixmee-tag
                   (apply #'concat (mapcar #'drmrd/regexp-matching-char-case-insensitively
                                           (coerce fixmee-tag 'list))))
                 "+"))
               (remaining-tags (rest tags)))
          (if remaining-tags
              (concatenate 'string
                           fixmee-string
                           "\\|"
                           (apply #'drmrd/words-to-fixmees remaining-tags))
            fixmee-string)))

      (defcustom drmrd/fixmee-keywords '("todo" "maybe" "started" "fixme" "citeme"
                                         (XXX case-sensitive))
        "The keywords that indicate tasks to be highlighted in `fixmee-mode'.

  Case-insensitive keyword <keyword> should be given as either a string or symbol
  while a case-sensitive <keyword> should be provided as a cons cell
  (<keyword> case-sensitive). See the documentation and value of
  `fixmee-notice-regexp' to get a better idea how these are passed into
  `fixmee-mode'.

  Elisp-escaped regular expression strings might work here, too, so long as they
  do not include (numbered) matching groups. At this time, however, they are not
  officially supported."
      :tag "List of Fixmee Keywords"
      :type '(repeat sexp)
      :link '(variable-link fixmee-notice-regexp)
      :group 'drmrd)

      ;; TODO: (2017-06-11) See what, if any, of the junk in this regexp can be
      ;;                    removed.
      ;; TODO: (2017-06-11) After cleaning up this regexp, make it aware of dates
      ;;                    & trailing tags.
      (setq-default fixmee-notice-regexp
            (concat ; "[<>v\^[:space:]]*"
                    "\\("
                      "@@@+"
                    "\\|"
                      "\\_<"  ;  '\_<' == Beginning of a "symbol"
                      "\\(?:" ; The keyword in the fixmee notice (except @@@[])
                        (apply #'drmrd/words-to-fixmees
                               drmrd/fixmee-keywords)
                      "\\)"
                    "\\)"
                    "\\(?:" ; Patterns that can end a fixmee notice
                      "[/:?!.[:space:]\\n]+"
                    "\\|"
                      "-+\\(?:\\s-\\|[\n]\\)"
                    "\\|"
                      "\\_>" ;  '\_>' == End of a "symbol"
                    "\\)"))

      (setq fixmee-cache-refresh-interval 5)

    :config
      (set-face-attribute 'fixmee-notice-face nil
                          :background "white"
                          :foreground "red"
                          :weight 'bold)

      (global-fixmee-mode 1))
#+END_SRC
*** TODO Come up with a good replacement for the fixmee-goto-next-by-position keybinding
This is M-p by default, but that is currently being used by ace-window.
** gnutls                                                    :gnutls:TLS:SSL:
TLS and SSL support in Emacs.

By default, GnuTLS accepts primes of bit length at least 256 in key
exchanges. We beef this number up to add a bit more
security/protection from man-in-the-middle attacks.
#+SRC_NAME set_gnutls-min-prime-bits
#+BEGIN_SRC emacs-lisp
  ;(setq gnutls-min-prime-bits 4096)
  ;(setq gnutls-min-prime-bits 2048)
  (setq gnutls-min-prime-bits 1024)
#+END_SRC

To aid with debugging errors, I also modify the gnutls-log-level variable
globally. This controls how much debugging information is printed to the
=*Messages*= buffer when GnuTLS encounters an error. The default is 0, which
means show as little debugging information in the =*Messages*= buffer as
possible, and the other values from 1 through 5 follow the GnuTLS logging
conventions outlined in [[http://gnutls.org/documentation.html][its documentation]].

I find a good default for this value is either 1 or 2, the latter of which
includes both the "important messages" you get by setting it to 1 along with
more verbose "debugging data", with which you should be able to diagnose most
problems encountered between GnuTLS and Emacs.
#+SRC_NAME set_gnutls-log-level
#+BEGIN_SRC emacs-lisp
  (setq gnutls-log-level 1)
#+END_SRC
** guide-key                                :learning:guide_key:keybindings:
[[https://github.com/kai2nenobu/guide-key][guide-key mode]] displays Magit-like popup menus displaying all suffixes bound to
commands after a given key prefix has been pressed. This is great for learning
new keybindings.
#+SRC_NAME guide-key_use-package_and_config
#+BEGIN_SRC emacs-lisp
  (defun drmrd/guide-key/hook-for-org-mode ()
    (guide-key/add-local-guide-key-sequence "C-c")
    (guide-key/add-local-guide-key-sequence "C-c C-x")
    (guide-key/add-local-highlight-command-regexp "org-"))

  (use-package guide-key
    :config (setq guide-key/guide-key-sequence '("C-x r" "C-x 4")
                  guide-key/recursive-key-sequence-flag t
                  guide-key/highlight-command-regexp
                  '(("rectangle" . "hot pink")
                    ("register"  . "light green")
                    ("bookmark"  . "cyan")))
            (add-hook 'org-mode-hook 'drmrd/guide-key/hook-for-org-mode)
    :init (guide-key-mode 1))
#+END_SRC
** hydra                                       :hydra:Keybindings:Libraries:
Groups of keybindings/registers on steroids

#+SRC_NAME: load-hydra-config
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;; Load and configure `hydra'
  (use-package hydra
               :ensure
               :config
               (org-babel-load-file (expand-file-name "~/.emacs.d/lib/hydra.org")))
#+END_SRC
** keyfreq                                              :keyfreq:Keybindings:
A package for logging usage of keybindings. Use =keyfreq-show= to display the
current usage counts.

#+SRC_NAME enable_keyfreq
#+BEGIN_SRC emacs-lisp
  (use-package keyfreq
      :config (keyfreq-mode 1)
              (keyfreq-autosave-mode 1))
#+END_SRC
** math-symbol-list                          :Editing:InputMethods:Math:TeX:
This is really cool but hard to categorize.  I've taken the code in
[[https://emacs.stackexchange.com/a/3404/8643][this Emacs.SE answer]] with some slight modifications.  It enables a new =math=
input method similar to the =TeX= input method =C-\= but with basically every
math-related unicode symbol bound to something.  The actual symbols aren't
associated to their familiar LaTeX macro names at times, but whenever you're
bothered by that, you can just add the macro name to the =quail-define-rules=
command below with the appropriate Unicode code-point.  On the other hand,
they're consistently named, with, for instance, the negation of a relation
=\foo= usually bound to =\nfoo=. The bound code-points are also conveniently all
contained in the symbol table in the =ac-math= package.

We're also playing around with a modified form of Clark Grubb's excellent
[[https://github.com/clarkgrubb/latex-input][latex-input]] project, which we've named the "LaTeX" input source and store in its
own library file.

#+SRC_NAME math-symbol-list_use-package
#+BEGIN_SRC emacs-lisp
  (use-package math-symbol-lists :ensure t
    :config
    (progn
      (use-package ac-math :ensure t)
      (quail-define-package "math" "UTF-8" "" t)
      (quail-define-rules ; whatever extra rules you want to define...
       ("\\from"    #X2190)
       ("\\to"      #X2192)
       ("\\lhd"     #X22B2)
       ("\\rhd"     #X22B3)
       ("\\unlhd"   #X22B4)
       ("\\unrhd"   #X22B5)
       ("\\CC"      #X2102)
       ("\\NN"      #X2115)
       ("\\PP"      #X2119)
       ("\\QQ"      #X211A)
       ("\\RR"      #X211D)
       ("\\ZZ"      #X2124)
       ("\\impliedby" #X21D0)
       ("\\implies" #X21D2)
       ("\\iff"     #X21D4)
       ("\\notimpliedby" #X21CD)
       ("\\notimply" #X21CF)
       ("\\notiff"     #X21CE))
      (mapc (lambda (x)
              (if (cddr x)
                  (quail-defrule (cadr x) (car (cddr x)))))
            (append math-symbol-list-basic math-symbol-list-extended))
      (drmrd/load-library "LaTeX-input-method.org")))
#+END_SRC

*** TODO Support superscripts, subscripts, etc.
** paradox                                                  :paradox:PkgMgmt:
An updated package manager with better support for GitHub metadata. See the
documentation. Run it by calling M-x paradox-list-packages.  Note that the
Github token provided to paradox for Github integration is set in an [[*Paradox%20Github%20Token][earlier
section]].
#+BEGIN_SRC emacs-lisp
  (use-package paradox :ensure t
    :init (setq paradox-execute-asynchronously nil))
#+END_SRC
** popwin                                            :popwin:PopupWindows:UI:
#+BEGIN_SRC emacs-lisp
  (use-package popwin
    :config (popwin-mode))
#+END_SRC
** re-builder                                               :rebuilder:RegEx:
A regular expressions building helper for Emacs.

The Re-Builder (REgular expression BUILDER) package aids in
constructing regular expressions by highlighting all matches of the
current expression in the document, including different colors for
different capture groups and other amenities. It supports several
different styles of regular expressions (see the documentation), but
has been configured here to use the one that's probably the most
natural to me (and involves the fewest number of excess backslashes).

#+SRC_NAME enable-re-builder
#+BEGIN_SRC emacs-lisp
  (use-package re-builder
      :init (setq reb-re-syntax 'string))
#+END_SRC
** re-builder+                                :rebuilderplus:RegEx:DISABLED:
Upgrades to [[re-builder]] functionality, including =reb+-query-replace-regexp=,
which takes what's currently in a =re-builder= buffer and runs a
=query-replace-regexp= with it in the original buffer.

#+SRC_NAME load_re-builder+
#+BEGIN_SRC emacs-lisp :tangle no
  (require 're-builder+)
#+END_SRC
** strings                                           :strings:Lisp:Internals:
Add various string manipulation functions to Emacs
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package strings
    :config
      (add-hook 'pre-command-hook 'erase-nonempty-inactive-minibuffer))
#+END_SRC
*** TODO Ensure the second command doesn't create any conflicts with other packages
** undo-tree                                         :undotree:Undo:Editing:
Use =undo-tree-visualize= to visually navigate your entire undo history (as a
tree, naturally), change branches, etc.
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :diminish undo-tree-mode
    :init (global-undo-tree-mode)
    :config
      (setq undo-tree-history-directory-alist '(("." . "~/.emacs.d/.caches/undo-tree"))))
#+END_SRC
** TODO yasnippet                          :yasnippet:Completion:Templating:
Yet Another Snippet is a templating package for Emacs, enabling rapid template
creation and reuse. Snippets for use in =foo-mode= should be store in the
=~/.emacs.d/snippets/foo-mode= directory to ensure they're loaded
automatically.
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :config
      ; Override built-in snippet directories
      ;
      ; NOTE: ~/.emacs.d/snippets should ALWAYS be the first directory
      ; in this list, since we want it to override all other snippet
      ; commands in other directories (preference is always given to
      ; earlier instance of a given key in the list) and to be the
      ; default save location for new snippets. Accordingly, don't use
      ; add-to-list if you're going to add a directory to this
      ; list. (add-to-list pushes its second argument onto the top of
      ; its first.) Instead, use
      ;
      ;     (setq yas-snippet-dirs (append yas-snippet-dirs
      ;                                '(<other directories>))
      ;
      ; to add <other directories> to the list.
      (setq yas-snippet-dirs
        '("~/.emacs.d/snippets" "~/Downloads/ThirdPartySnippets"))
      (yas-reload-all)
      (yas-global-mode 1))
#+END_SRC
*** TODO Look into Emacs's built-in templating functionality (like abbrev, skeletons, etc.)
=yasnippet= is fantastic for creating simple text replacement templates
(possibly involving variables), but it lacks certain killer pieces of
functionality that I'd love to see. For instance, in LaTeX modes,
*** TODO Dive deeper into advanced yasnippeting
Take a look at the following example snippets that are in the package's snippet
repo.
#+NAME simple_matching_and_entered_string_analysis
#+BEGIN_EXAMPLE
  (${1:name} :initarg :${1:$(yas/substr yas-text "[^: ]*")}
             :initform (error ":${1:$(yas/substr yas-text "[^: ]*")} must be specified")
             ;; :accessor ${1:$(yas/substr yas-text "[^: ]*")}
             :reader ${1:$(yas/substr yas-text "[^: ]*")}-changed

#+END_EXAMPLE

#+NAME reflection
#+BEGIN_EXAMPLE
  \${${2:n}:${4:\$(${5:reflection-fn})}\}$0
#+END_EXAMPLE

Here's a little example illustrating transformations. Note that the first dollar
sign in the pair can be replaced with any non-empty string (possibly with a few
character limitations I'm unaware of). Something is needed there for the
interpreter to be able to distinguish between "mirrors" and "transformations".

#+NAME transformation
#+BEGIN_EXAMPLE
  # name: alternator
  # contributor: Daniel Moore
  # key: alternator
  # --
  ${1:$$(apply #'string (reverse (string-to-list yas-text)))}$0
#+END_EXAMPLE

Here's a clever hack (that's since been replaced with something better in the
current version of this snippet). The following allows you to selectively delete
the =\label{...}= in a LaTeX environment without escaping from the snippet.
#+BEGIN_EXAMPLE
  # -*- mode: snippet; require-final-newline: nil -*-
  # name: begin
  # key: begin
  # group: environments
  # contributor: Daniel Moore
  # --
  \begin{$1}${2:
      \label{${3:<label here>}}}
      $0
  \end{$1}
#+END_EXAMPLE

Or how about comment snippets that work in all programming language modes
without any additional configuration? The following several snippets can be
defined for =prog-mode= to enable this functionality. First, one defines some
functions in a =.yas-setup= file in the =prog-mode= snippets directory.

#+NAME yas-setup_file_example
#+BEGIN_EXAMPLE emacs-lisp
  (require 'yasnippet)

  (defun yas-with-comment (str)
    (format "%s%s%s" comment-start str comment-end))

  ;; whitespace removing functions from Magnar Sveen ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (defun yas-s-trim-left (s)
    "Remove whitespace at the beginning of S."
    (if (string-match "\\`[ \t\n\r]+" s)
        (replace-match "" t t s)
      s))

  (defun yas-s-trim-right (s)
    "Remove whitespace at the end of S."
    (if (string-match "[ \t\n\r]+\\'" s)
        (replace-match "" t t s)
      s))

  (defun yas-s-trim (s)
    "Remove whitespace at the beginning and end of S."
    (yas-s-trim-left (yas-s-trim-right s)))


  (defun yas-string-reverse (str)
    "Reverse a string STR manually to be compatible with emacs versions < 25."
    (apply #'string
           (reverse
            (string-to-list str))))

  (defun yas-trimmed-comment-start ()
    "This function returns `comment-start' trimmed by whitespaces."
    (yas-s-trim comment-start))

  (defun yas-trimmed-comment-end ()
    "This function returns `comment-end' trimmed by whitespaces if `comment-end' is not empty.
  Otherwise the reversed output of function `yas-trimmed-comment-start' is returned."
    (if (eq (length comment-end) 0)
        (yas-string-reverse (yas-trimmed-comment-start))
      (yas-s-trim comment-end)))
#+END_EXAMPLE

Now we can define our functions. The first inserts a single-line comment.
#+NAME single-line_comment_for_ALL_programming_modes
#+BEGIN_EXAMPLE
  # -*- mode: snippet -*-
  # contributor: sh-ow <sh-ow@users.noreply.github.com>
  # name: comment
  # key: co
  # --
  ${1:$(yas-trimmed-comment-start)} ${1:comment}${1:$(unless (eq (length comment-end) 0) (concat " " (yas-trimmed-comment-end)))}$0
#+END_EXAMPLE

How about a snippet to comment out lines in *all* programming languages?
#+NAME line
#+BEGIN_EXAMPLE
  # -*- mode: snippet -*-
  # contributor: sh-ow <sh-ow@users.noreply.github.com>
  # name: commentline
  # key: col
  # --
  ${1:$(yas-trimmed-comment-start)} ${1:comment} ${1:$(let* ((str "")
                                                 (curr (current-column))
                                                 (start (yas-trimmed-comment-start))
                                                 (lastcom (substring start -1))
                                                 (end (yas-trimmed-comment-end)))
                                               (while (< (length str) (- 79 (+ curr (length end))))
                                                      (setq str (concat str lastcom)))
                                             (concat str end))}$0
#+END_EXAMPLE

Not complex enough for you? Here's a multiline comment generator that works in
*all* programming languages...and auto wraps lines!!!
#+NAME block_comment_for_*prog-mode*___so_for_ALL_programming_modes
#+BEGIN_EXAMPLE emacs-lisp
  # -*- mode: snippet -*-
  # contributor: sh-ow <sh-ow@users.noreply.github.com>
  # name: commentblock
  # key: cob
  # --
  ${1:$(let* ((col (current-column))
             (str "")
             (lastcom (substring (yas-trimmed-comment-start) -1))
             (start (yas-trimmed-comment-start))
             (end (yas-trimmed-comment-end))
             (over (- (+ (string-width yas-text) (length start) (length end) col) 77)))
           (while (< (length str) (+ (- 79 (length start) (length end) col) (if (> over 0) over 0)))
                  (setq str (concat str lastcom)))
         (concat start str end))}
  ${1:$(let* ((col (current-column))
             (str "")
             (start (yas-trimmed-comment-start))
             (end (yas-trimmed-comment-end)))
           (while (< (length str) (ffloor (/ (- 78.0 (+ col (length start) (string-width yas-text) (length end))) 2.0)))
                  (setq str (concat str " ")))
          (concat start str))} ${1:comment} ${1:$(let* ((col (current-column))
                                                       (str "")
                                                       (start (yas-trimmed-comment-start))
                                                       (end (yas-trimmed-comment-end)))
                                                     (while (< (length str) (- 79.0 (if (eq (mod (string-width yas-text) 2) 1) (- col 1) col) (length end)))
                                                            (setq str (concat str " ")))
                                                   (concat str end))}
  ${1:$(let* ((col (current-column))
             (str "")
             (lastcom (substring (yas-trimmed-comment-start) -1))
             (start (yas-trimmed-comment-start))
             (end (yas-trimmed-comment-end))
             (over (- (+ (string-width yas-text) (length start) (length end) col) 77)))
           (while (< (length str) (+ (- 79 (length start) (length end) col) (if (> over 0) over 0)))
                  (setq str (concat str lastcom)))
         (concat start str end))}$0
#+END_EXAMPLE
** ws-butler                                          :Whitespace:ws_butler:
Automatically remove trailing whitespace on save, but only on lines that you've
made other changes to. This is amazingly useful when committing to a repo.
#+SRC_NAME ws-butler_use-package
#+BEGIN_SRC emacs-lisp
  (use-package ws-butler :ensure t
    :config (ws-butler-global-mode))
#+END_SRC
** TODO Color-identifiers-mode (Unique display colors for unique variables)
** Visible-Mark: Make the Current Mark Visible
#+SRC_NAME enable_visible-mark-mode_globally
#+BEGIN_SRC emacs-lisp :tangle no
  (global-visible-mark-mode 1)
#+END_SRC
** DISABLED Packages
Here is a list of packages that I used to load globally but whose
functionality has been replaced by something else.
*** Auto-YASnippet: Create Temporary YASnippets
Create a temporary snippet for reproducing similar code repeatedly in
a file. To get an idea of how to use this, the following example is
provided by the package.
#+SRC_NAME: Auto-YASnippet_JavaExample
#+BEGIN_EXAMPLE
  In Java write:
  class Light$On implements Runnable {
    public Light$On() {}
    public void run() {
      System.out.println("Turning $on lights");
      light = $true;
    }
  }
  This differs from the code that you wanted to write only by 4 $ chars.
  Since it's more than one line, select the region and call `create-auto-yasnippet'.
  The $ chars disappear, yielding valid code.
  `*current-auto-yasnippet-template* becomes:
  "class Light$1 implements Runnable {
    public Light$1() {}
    public void run() {
      System.out.println(\"Turning $2 lights\");
      light = $3;
    }
  }"
#+END_EXAMPLE
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package auto-yasnippet
    :bind
      (("H-w" . aya-create)
       ("H-y" . aya-expand)))
#+END_SRC
**** *Update (2016-05-04):* Disable auto-yasnippet
I've disabled this package since I have yet to actually use
it. I don't see a good use case for it that in my work that isn't
already covered by other packages (or could be covered in a more
broadly-applicable manner, e.g., by the multiple-cursors package). The
package does its job great, though, so I've left it here in case I
wish to enable it in the future, possibly for specific modes instead
of globally.
*** Company (Auto-Completion Support): COMPlete ANYthing :company:Completion:Templating:
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package company
    :after yasnippet
    :config
      (add-hook 'after-init-hook 'global-company-mode)
      (global-company-mode)

      ; Set # of seconds after typing and before suggestions are shown
      (setq company-idle-delay 0.5)

      ; Weight suggestions by use frequency
      (setq company-transformers '(company-sort-by-occurrence))
#+END_SRC
The configuration here that ensures yasnippet and company play well
together is adapted from [[https://www.reddit.com/r/emacs/comments/3r9fic/best_practicestip_for_companymode_andor_yasnippet/][this reddit post]].
#+BEGIN_SRC emacs-lisp :tangle no
      ;; Code for yasnippet compatibility
      ; Add yasnippet support for all company backends
      ;     (See https://github.com/syl20bnr/spacemacs/pull/179)
      (defvar company-mode/enable-yas t
              "Enable yasnippet for all company backends.")
      (defun company-mode/backend-with-yas (backend)
        "Add `company-yasnippet' to the backend if it is not already
        present and yasnippet is enabled in company mode. Otherwise do
        nothing."
        (if (or (not company-mode/enable-yas)
                (and (listp backend)
                  (member 'company-yasnippet backend)))
            backend
            (append (if (consp backend) backend (list backend))
              '(:with company-yasnippet))))
      ; Apply the company-mode/backend-with-yas function to all
      ; company backends (if yasnippet is enabled in company mode).
      (setq company-backends (mapc #'company-mode/backend-with-yas
                                   company-backends))
      ;; End of company/yasnippet compatibility code
#+END_SRC
Next we add hooks for company mode backends for particular major
modes. (I'm still debating on whether or not it would be better to
move this code down to where each major mode is defined, but it will
stay here for the time being, the rationale being that it will be
easier to disable/modify the full company configuration if all of this
code is in one place.)
#+BEGIN_SRC emacs-lisp :tangle no
    ;; Configure company-mode for editing LaTeX files
    (defun drmrd/company-mode/load-latex-backends ()
      ; Add LaTeX backends to company-backends
      (setq-local company-backends
        (append '((company-math-symbols-latex company-latex-commands))
                company-backends))
      ; Right-align annotation symbols in completion windows
      (setq-local company-tooltip-align-annotations t))
  )
#+END_SRC

*** (Disabled) Display the Current Directory                     :uniquify:
#+BEGIN_SRC emacs-lisp :tangle no
  ;; Help ensure displayed buffer names are unique for files with the
  ;; same names.
  (use-package uniquify
    :config (setq uniquify-buffer-name-style 'forward)) ; /foo/bar/baz
#+END_SRC
*** flyspell-lazy                              :flyspelllazy:SpellChecking:
Load the third-party flyspell-lazy.elc script, which improves flyspell's
responsiveness by forcing it to only check spelling when Emacs has been idle for
a little while (as opposed to damn near constantly).

#+BEGIN_SRC emacs-lisp :tangle no
  (require 'flyspell-lazy)
  (flyspell-lazy-mode 1)
#+END_SRC

**** NOTE: Flyspell must be loaded AFTER this code executes
Right now this isn't a problem, since flyspell is loaded via major mode hooks
(see the ./lib/latex.org config file for an example), but should we decide to
use it globally this code might need to be moved.
**** DISABLE 2016-11-02
This mode is not available through ELPA and, as indicated [[https://github.com/rolandwalker/flyspell-lazy][in its documentation]],
is only useful if you're seeing a performance hit when running =flyspell=. I
believe I set this up on my office iMac when =flyspell= was making things grind
to a halt, but on Linux I don't seem to have any need for it. If I start using
Aquamacs on that iMac again I might enable it globally or (more likely) just on
OS X/macOS (=darwin= systems).
** Markdown Mode                                                  :Markdown:
#+SRC_NAME markdown-mode_use-package
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'"       . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "multimarkdown"))
#+END_SRC
** Multiple Cursors Mode
#+SRC_NAME multiple-cursors_use-package
#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors :ensure t
    :config (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
            (global-set-key (kbd "C->") 'mc/mark-next-like-this)
            (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
            (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this))
#+END_SRC
** which-key                                         :which_key:Keybindings:
~which-key~ displays all possible completions of an incomplete key prefix in a
popup window. Our configuration is based on (if not taken /verbatim/ from)
[[https://github.com/kaushalmodi/.emacs.d/blob/master/setup-files/setup-which-key.el][kaushalmodi's .emacs.d repo]].

*Update (2024-03-03):* I'm getting an error on startup when attempting to use
~which-key~ mode and ~helm-descbinds-mode~ simultaneously, since they try to do
the same thing and conflict. I'm disabling ~which-key~ mode accordingly.

#+SRC_NAME which-key_use-package
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package which-key
    :defer 10
    :config
    (progn
      (setq which-key-popup-type 'side-window) ;Default
      ;; (setq which-key-popup-type 'minibuffer)

      (setq which-key-compute-remaps t) ;Show correct descriptions for remapped keys

      (setq which-key-allow-multiple-replacements t) ;Default = nil

      (setq which-key-replacement-alist
            '(
              ;; Replacements for how part or whole of FUNCTION is replaced when
              ;; which-key displays
              ;;   KEY  FUNCTION
              ;; Eg: After "d" in `calc', display "6  calc-hex-radix" as "6  hex-radix"
              ((nil . "Prefix Command")           . (nil . "prefix"))
              ((nil . "which-key-show-next-page") . (nil . "wk next pg"))
              ((nil . "\\`calc-")                  . (nil . "")) ;Hide "calc-" prefixes when listing M-x calc keys
              ((nil . "\\`artist-select-op-")      . (nil . "")) ;Make artist-mode function names less verbose
              ((nil . "\\`artist-select-")         . (nil . "sel-"))
              ((nil . "\\`artist-toggle-")         . (nil . "toggle-"))
              ((nil . "modi/")                    . (nil . "m/")) ;The car is intentionally not "\\`modi/" to cover cases like `hydra-toggle/modi/..'.
              ((nil . "\\`hydra-\\(.+\\)/body\\'")      . (nil . "h/\\1"))
              ((nil . "\\`org-babel-")             . (nil . "ob/"))
              ;; Replacements for how KEY is replaced when which-key displays
              ;;   KEY  FUNCTION
              ;; Eg: After "C-c", display "right  winner-redo" as "  winner-redo"
              (("<\\(.*\\)-?left>"   . nil)         . ("\\1" . nil))
              (("<\\(.*\\)-?right>"  . nil)         . ("\\1" . nil))
              (("<\\(.*\\)-?up>"     . nil)         . ("\\1" . nil))
              (("<\\(.*\\)-?down>"   . nil)         . ("\\1" . nil))
              (("<\\(.*\\)-?return>" . nil)         . ("\\1" . nil))
              (("RET" . nil)                      . ("" . nil))
              (("<\\(.*\\)-?delete>" . nil)         . ("\\1" . nil)) ;Delete key
              (("DEL"  . nil)                     . ("BS" . nil)) ;Backspace key
              (("<\\(.*\\)-?backspace>" . nil)      . ("\\1BS" . nil)) ;Backspace key
              (("<\\(.*\\)-?tab>"   . nil)          . ("\\1TAB" . nil))
              (("SPC"   . nil)                    . ("" . nil))
              (("<\\(.*\\)-?next>"   . nil)         . ("\\1PgDn" . nil))
              (("<\\(.*\\)-?prior>"  . nil)         . ("\\1PgUp" . nil))
              ))
      ;; Use cool unicode characters if available
      (with-eval-after-load 'setup-font-check
        (when font-symbola-p
          (add-to-list 'which-key-replacement-alist '((nil . "\\`calc-") . (nil . "")))
          (add-to-list 'which-key-replacement-alist '((nil . "\\`engine/search-") . (nil . " "))))) ;engine-mode

      ;; Change what string to display for a given *complete* key binding
      ;; Eg: After "C-x", display "8  +unicode" instead of "8  +prefix"
      (which-key-add-key-based-replacements
        "C-x 8"   "unicode"
        "C-x a"   "abbrev/expand"
        "C-x r"   "rectangle/register/bookmark"
        "C-x v"   "version control"
        "C-c /"   "engine-mode-map"
        "C-c C-v" "org-babel"
        "C-x 8 0" "ZWS")

      ;; Highlight certain commands
      (defface modi/which-key-highlight-2-face
        '((t . (:inherit which-key-command-description-face :foreground "indian red")))
        "Another face for highlighting commands in `which-key'.")

      (defface modi/which-key-highlight-3-face
        '((t . (:inherit which-key-command-description-face :foreground "DarkOrange3")))
        "Another face for highlighting commands in `which-key'.")

      (setq which-key-highlighted-command-list
            '(("\\`hydra-" . which-key-group-description-face)
              ;; Highlight using the `modi/which-key-highlight-2-face'
              ("\\`modi/" . modi/which-key-highlight-2-face)
              ;; Highlight using the `modi/which-key-highlight-3-face'
              ("\\`bookmark-" . modi/which-key-highlight-3-face)
              ("\\`counsel-" . modi/which-key-highlight-3-face)
              ;; Highlight using the default `which-key-highlighted-command-face'
              "\\`describe-"
              "\\(rectangle-\\)\\|\\(-rectangle\\)"
              "\\`org-"))

      (which-key-mode 1)))
#+END_SRC
* Performance Settings
The following settings improve the performance of Emacs in various
ways, typically by permitting it to assume our computer wasn't built
in the stone age. They also provide various methods by which we can
benchmark our init settings.

Other ideas for speeding up Emacs can be found in
[[https://www.reddit.com/r/emacs/comments/2094tl/how_can_i_improve_emacs_performance/][this reddit thread]], from which several of the functions/ideas that
follow were taken.
** Force Emacs to fully redraw windows *before* processing queued input events
The following should dramatically reduce the amount of screen tearing
you see while working with Emacs.
#+BEGIN_SRC emacs-lisp :tangle no
  (setq redisplay-dont-pause t)
#+END_SRC
*** TODO Remove this setting after updating to Emacs v. 24.5 on all machines
This setting is the default behavior in Emacs v. 24.5 and higher, and
I read in a comment somewhere (confirm this) that the above variable
is going to be deemed deprecated soon. Alternatively (and better),
just wrap this command in a version check.
* Major Mode Customization
#+SRC_NAME major_modes_section_marker
#+BEGIN_SRC emacs-lisp
  ;;;; Major Mode Customizations
#+END_SRC
** Dired Mode: Directory Browsing/Editing      :Dired:DirectoryTreeBrowsing:
*** Wdired Mode                                                    :Wdired:
One of the killer features in Emacs that I originally stumbled on accidentally
is Dired's "writable" mode. If you press ~C-x C-q~ (or whatever your
~toggle-read-only~ keybinding is set to) while in dired mode (like I did as a
joke), you'll discover that it does /exactly what you'd expect/; you'll be able
to rename files in the current directory by just editing their names in the
dired buffer, delete files by completely deleting their names, and even move
files by adding relative/abolute paths to their names. Best of all, ~wdired~
only performs these changes after you "commit" them with ~C-c C-c~ (or by
hitting ~C-x C-q~ again and confirming), and you can revert your proposed
changes at any time by typing ~C-c C-k~. It also works flawlessly on remote
system with ~tramp~, and it's up there with [[help:dired-do-query-replace-regexp][~dired-do-query-replace-regexp~]] as
one of my all-time favorite sysadmin workflow features within ~dired~.

~wdired~ is baked into ~dired~ by default, with all of those features
standard. The following takes this a step further by allowing you to edit the
only remaining part of the ~dired~ buffer that makes sense to edit in ~wdired~
mode: file permissions!
#+SRC_NAME wdired_config
#+BEGIN_SRC emacs-lisp
  (setq wdired-allow-to-change-permissions t)
#+END_SRC
** CC Mode: Editing in C-like languages             :CCmode:C:Cpp:Java:Perl:
*** Code Style and Indentation                      :Indentation:CodeStyle:
#+SRC_NAME CC-mode
#+BEGIN_SRC emacs-lisp
  ;; By default, CC modes use the "gnu" coding style, which means code
  ;; will look like the following by default:
  ;;
  ;;     if(foo)
  ;;       {
  ;;         bar++;
  ;;       }
  ;;
  ;; Since this is uncomfortably ugly, we change it to the more
  ;; civilized "linux" coding style used in Linux kernel development.
  (setq c-default-style "linux")

  ;; While we're at it, let's set the default "tab" size to be four
  ;; spaces.
  (setq c-basic-offset 4)

  ;; Indent cases within switch statements.
  (c-set-offset 'case-label '+)
#+END_SRC
** Info Mode: Adding custom sections to =*info*=
#+SRC_NAME info-mode-custom-directories
#+BEGIN_SRC emacs-lisp
  ;; Add `[.emacs.d/]info/' to the Info-mode directory list, a custom
  ;; directory containing documentation that we'd like to add to
  ;; info-mode.
  (add-to-list 'Info-default-directory-list
               (expand-file-name "./info/" user-emacs-directory))
#+END_SRC
*** TODO Create custom info files for modes that don't supply them (and personal notes)
** Use Terminals within Emacs                                       :Eshell:
Use [[help:eshell][eshell]]!

** eww: Internet browser integrated into Emacs              :eww:Keybindings:
Beginning in v24.4, Emacs comes equipped with an internet browser =eww= that
supports basic HTML and CSS. Our config was inspired by [[https://github.com/dakrone/eos/blob/master/eos-web.org][dakrone's]].

First we replace the usual email command bound to "C-x m" with
=browse-url-at-point=
#+SRC_NAME eww_define_C-x_m
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x m") 'browse-url-at-point)
#+END_SRC

#+SRC_NAME load_eww
#+BEGIN_SRC emacs-lisp
  (use-package eww
    :defer t
    :init
      ;; Improve eww's readability
      (add-hook 'eww-mode-hook #'toggle-word-wrap)
      (add-hook 'eww-mode-hook #'visual-line-mode))
#+END_SRC

#+SRC_NAME load_eww-lnum
#+BEGIN_SRC emacs-lisp
  ;; Improve page navigation in eww with eww-lnum
  (use-package eww-lnum
    :ensure t
    :bind (:map eww-mode-map
           ("f" . eww-lnum-follow)
           ("U" . eww-lnum-universal)))
#+END_SRC
*** Usage Notes
- =eww= will only run on versions of Emacs compiled with libxml2. (In fact, you
  can tell whether or not your emacsen are running libxml2 by trying to use
  =eww= to access a website; it should complain about it almost immediately.) It
  also appears that the version of Emacs attainable through =apt-get= (at least
  on Linux Mint, between early-2015 and mid-2016) was not compiled with libxml2.
*** Future Projects
**** TODO Get =C-x m= to handle other link types (including org-links) appropriately
** TODO Change Log Mode
[[help:change-log-mode][=change-log-mode=]] is enabled by default for files case-insensitively entitled
=CHANGELOG=. While I'm sure this is a wonderful mode for certain changelogs, it
defaults to 8 spaces of indentation in the body.
** Emacs-Lisp Mode
We use the built-in emacs-lisp-mode for editing .el files, but with a couple
quality of life tweaks incorporated.
*** Fix electric-indent-mode when in Emacs-Lisp mode
The following code addresses an oddity in the interaction between Electric
Indent Mode and Emacs-Lisp Mode. Without it, hitting return on a line beginning
with a semi-colon in an elisp file will result in that line being indented by
40-ish characters.

See the following if similar issues arise in other modes:
    http://emacs.stackexchange.com/q/3322
    http://emacs.stackexchange.com/q/9563

#+BEGIN_SRC emacs-lisp
  (defun electric-indent-mode-remove-newline-from-indent-chars ()
         "Delete newline (?\n) from `electric-indent-chars'."
         (setq electric-indent-chars (delq 10 electric-indent-chars)))
  (add-hook 'emacs-lisp-mode-hook #'electric-indent-mode-remove-newline-from-indent-chars)
#+END_SRC

** Helm                                          :helm:Completion:Navigation:
An /extremely/ versatile framework for manipulating, searching, etc. within data
sources of all kinds. Helm and its extensions allow everything from completely
replacing =ido= and =smex= for finding files and commands to controlling Spotify
from within Emacs. This is my second attempt to switch to =helm= from =ido=, and
I think I'll stick with it this time around.

#+SRC_NAME load-helm-library
#+BEGIN_SRC emacs-lisp
  (org-babel-load-file (expand-file-name "~/.emacs.d/lib/helm.org"))
#+END_SRC
** (La)TeX Mode
Next we load the file ~/.emacs.d/lib/latex.org, which contains and/or
dynamically loads all of our custom LaTeX settings.

#+SRC_NAME load-latex-config
#+BEGIN_SRC emacs-lisp
  ;;; (La)TeX Mode
  ;;;
  ;;;     Loads our configuration library for LaTeX-related major modes and
  ;;;     AUCTeX. Naturally it is primarily focused on `TeX-mode' and
  ;;;     `LaTeX-mode', but it also includes settings and hooks for, e.g.,
  ;;;     `outline-minor-mode', the `outline-magic' package, and (depending on my
  ;;;     mood) `preview-latex'.
  (org-babel-load-file (expand-file-name "~/.emacs.d/lib/latex.org"))
#+END_SRC
** Org Mode
Our Org mode configuration has been slowly but surely growing to a size where it
now deserves its own config library.

#+SRC_NAME load-org-config
#+BEGIN_SRC emacs-lisp
  ;;; Org-Mode
  ;;;
  ;;;     Loads our Org-mode config library. This includes customization for all
  ;;;     official and community `org-*' modes/packages (e.g., both `org-agenda',
  ;;;     `org-babel', and `org-pomodoro'), in addition to general org tweaks.
  (org-babel-load-file (expand-file-name "~/.emacs.d/lib/org.org"))
#+END_SRC
** Magit                                          :Magit:Git:VersionControl:
[[info:magit#Top][Magit]] is a Git porcelain (aka frontend) for Emacs. We load Magit and bind C-x g
to the magit-status function (really the only command you'll ever invoke).

Use "s" to stage a file, "c c" to start a commit, "C-c C-c" to finish a commit,
"b b" to switch branches, "P P" to do a git push, and "F F" to do a git
pull. [Tab] is also a nice key.

#+SRC_NAME magit_use-package
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package magit
    :init (remove-hook 'find-file-hook 'vc-find-file-hook)
          ;; Hide magit's work in progress mode lighters.
          (delight '((magit-wip-after-save-mode nil nil)
                     (magit-wip-after-apply-mode nil nil)
                     (magit-wip-before-change-mode nil nil)))
          (setq magit-wip-after-save-local-mode nil
                magit-wip-after-apply-mode-lighter nil
                magit-wip-before-change-mode-lighter nil)
          ;; Make magit highlight actual changes in lines in a brighter color
          ;; than the rest of the current hunk. Set to 'all to do this in all
          ;; hunks instead (or nil to disable this).
          (setq magit-diff-refine-hunk t)
          ;; Enable commit style convention checking with recommended defaults.
          (setq git-commit-style-convention-checks '(non-empty-second-line
                                                     overlong-summary-line)
                git-commit-summary-max-length 50
                git-commit-fill-column 72)

  ;;         ;; TODO: This function needs to be fixed to work with the most
  ;;         ;;       recent magit versions
  ;;         ;; TODO: (2017-06-03) Adjust this experimental function as needed.
  ;;         (defun drmrd/magit/change-section-visibility-defaults(section)
  ;;           "Tweak which sections are collapsed by default in magit buffers.
  ;;
  ;; Use this function by adding it to `magit-section-set-visibility-hook'."
  ;;           (let ((section-type (magit-section-type section))
  ;;                 (section-value (magit-section-value section)))
  ;;             (when (or (and (memq section-type '(unpulled unpushed))
  ;;                            (string-match-p "@{upstream}" section-value))
  ;;                       (and (eq section-type 'stashes)
  ;;                            (string-match-p "refs/stash" section-value)))
  ;;               'hide)))
  ;;
  ;;         (add-hook 'magit-section-set-visibility-hook
  ;;                   'drmrd/magit/change-section-visibility-defaults)

          ;; TODO: (2017-05-29) Create a drmrd/git-repository-locations custom
          ;; variable that uses some kind of drmrd/setq-list-with-secrets function
          ;; to generate a list of local and remote repos. This should somehow
          ;; (using another custom function) conditionally include TRAMP repos
          ;; like those in
          ;;
          ;;     /ssh:drmrd-remote-user@drmrd-remote-host:/drmrd/remote/repos
          ;;
          ;; when SSH connections exist providing access to them. (Care needs to
          ;; be taken to ensure that repos are only listed from machines I own,
          ;; though.)

          ;; Inform Magit where to look for repositories on this system, for use
          ;; with the `magit-list-repositories' function.
          (setq magit-repository-directories '(("~/workspace" . 2)))

    :config ;; Disable magit-auto-revert-mode
        (setq magit-restore-window-configuration t) ; that's the default actually
        (setq magit-status-buffer-switch-function
              (lambda (buffer) ; there might already be an Emacs function which does this
                (pop-to-buffer buffer)
                (delete-other-windows)))
                (magit-auto-revert-mode -1)

        ;; Prevent the built-in VC package from doing work in the background by
        ;; disabling it in Git repositories.
        (setq vc-handled-backends (delq 'Git vc-handled-backends))
    :bind ("C-x g" . magit-status))
#+END_SRC

** mu4e
An actively developed and feature-full email client in Emacs. See the wonderful
[[http://www.djcbsoftware.nl/code/mu/mu4e/index.html#SEC_Contents][manual]] for all your basic installation and configuration needs.

#+SRC_NAME load_mu4e_config
#+BEGIN_SRC emacs-lisp :tangle no
  (org-babel-load-file (expand-file-name "~/.emacs.d/lib/mu4e.org"))
#+END_SRC
*** TODO Fail gracefully on systems without mu(4e) installed
** Visible Mark Mode                       :Mark:Regions:Navigation:Appearance:UI:
Make the current mark visible in each buffer.
#+SRC_NAME visible-mark-mode_use-package
#+BEGIN_SRC emacs-lisp
  (use-package visible-mark :ensure t
    :config (visible-mark-mode))
#+END_SRC
** Volatile Highlight Mode               :Changes:Appearance:UI:Highlighting:
Highlight all changes made to the current buffer since a recent command. Great
for keeping track of what you're saving in an unobtrusive way. Depending on your
theme it can be a super subtle but great quality of life improvement.
#+SRC_NAME volatile-highlights-mode_use-package
#+BEGIN_SRC emacs-lisp
  (use-package volatile-highlights
    :config (volatile-highlights-mode)
    :diminish volatile-highlights-mode)
#+END_SRC
* Emacs Server Setup                                     :emacsclient:server:
#+SRC_NAME start_emacs_server
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'server)
  (unless (server-running-p)
    ; (setq server-socket-dir (expand-file-name "server" user-emacs-directory))
    (server-start))
#+END_SRC

The following hack from [[https://lists.gnu.org/archive/html/help-gnu-emacs/2010-04/msg00151.html][Jim Burton]] uses a terminal-compatible theme for terminal
frames while using a fancier theme in GUI frames. Using fancy themes with a
daemonized Emacs will lead to init errors without something like this in place.

Setting ~color-theme-is-global~ to ~nil~ makes the hook only affect the current
frame (not all frames at once).
#+SRC_NAME set_color_theme_differently_in_terminal_frames
#+BEGIN_SRC emacs-lisp :tangle no
  (setq color-theme-is-global nil)
  (add-hook 'after-make-frame-functions
            '(lambda (f)
               (with-selected-frame f
                 (if (window-system f)
                     (color-theme-gray30)
                   (color-theme-emacs-nw)))))
#+END_SRC
** HOLD Move server stuff back to .profile
- State "HOLD"       from "TODO"       [2017-05-13 Sat 18:06] \\
  No longer sure if the =emacs --daemon= approach (and its ilk) are better than
  just conditionally doing the server start here. If I want to start the server
  when the OS starts, I should just leave this here and add an =emacs --daemon==
  call in =.profile= instead.
* Clean Up
** Close Extra Frames in Aquamacs
For some reason (in Aquamacs only) my configuration files open
multiple frames as they're being processed. So we close them after
loading everything. At present, this doesn't seem to work.
#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin)
    (delete-other-frames))
#+END_SRC
** Disable Debugging
Now that we've loaded all of our config files, disable debugging.
#+BEGIN_SRC emacs-lisp
  (setq debug-on-error nil)
  (setq debug-on-quit nil)
#+END_SRC
** Record when config finishes loading
Record the time when all config files have finished loading.
#+SRC_NAME log_when_init_finishes_loading
#+BEGIN_SRC emacs-lisp
  (message "Finished loading Emacs configuration at %s"
           (format-time-string "%I:%M%p (%S.%3Ns)"))
#+END_SRC

* Footnotes
[fn:specialfcn] A /special/ function or form here will mean one that
takes at least one or more distinguished arguments followed by a
"body" (an arbitrary number of s-expressions in which the final
expression's value is returned). Examples include =if=, =let=,
=with-current-buffer=, etc.
* COMMENT Footer
