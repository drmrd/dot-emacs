#+TITLE: LaTeX Emacs Configuration
#+AUTHOR: DRMRD
#+PROPERTY: header-args    :tangle ~/.emacs.d/lib/latex.el :comments link :eval query :results output silent
#+OPTIONS: toc:nil num:nil ^:nil
#+STARTUP: indent

* latex.el Reference
** Determining the document structure at the current point
| Structure (@ Point) | Function                     |
|---------------------+------------------------------|
| Environment         | [[help:LaTeX-current-environment][LaTeX-current-environment]]    |
| Section             | [[help:LaTeX-current-section][LaTeX-current-section]]        |
| Indentation         | [[help:LaTeX-current-indentation][LaTeX-current-indentation]]    |
| Verbatim Macro      | [[help:LaTeX-current-verbatim-macro][LaTeX-current-verbatim-macro]] |
** Setting names related to SyncTeX
Most, if not all, of these are prefixed with ~TeX-source-correlate~. You +might+
probably will also need to set up the ~TeX-view-program-list~ to suit your
needs.
* SyncTeX
#+SRC_NAME
#+BEGIN_SRC emacs-lisp
  ;; Tells emacs where to find LaTeX.
  (let ((my-path (expand-file-name "/usr/local/bin:/usr/local/texlive/2017/bin/x86_64-darwin")))
    (setenv "PATH" (concat my-path ":" (getenv "PATH")))
    (add-to-list 'exec-path my-path))

  ;; AucTeX settings

  ;; (setq TeX-PDF-mode t)

  ;; (add-hook 'LaTeX-mode-hook
  ;;           (lambda ()
  ;;             (add-to-list 'TeX-command-list
  ;;                          '("latexmk" "latexmk -pdf %s"
  ;;                            TeX-run-TeX nil t
  ;;                            :help "Run latexmk on file"))))

  ;; (add-hook 'TeX-mode-hook '(lambda () (setq TeX-command-default "latexmk")))

  ;; (setq TeX-view-program-selection '((output-pdf "PDF Viewer")))
  ;; (setq TeX-view-program-list
  ;;       '(("PDF Viewer" "/Applications/Skim.app/Contents/SharedSupport/displayline -b -g %n %o %b")))

  (use-package pdf-tools
    :pin manual ;; Manually updated from GitHub source
    :config
    (progn (pdf-tools-install)
           (setq-default pdf-view-display-size 'fit-page)
           (setq pdf-annot-activate-created-annotations t)
           (setq pdf-view-resize-factor 1.1)
           (unless (assoc "PDF Tools" TeX-view-program-list-builtin)
             (add-to-list 'TeX-view-program-list-builtin
                          '("PDF Tools" TeX-pdf-tools-sync-view))
             (add-to-list 'TeX-view-program-selection
                          '(output-pdf "PDF Tools")))

           (setq TeX-view-program-selection '((output-pdf "PDF Tools"))
                 TeX-source-correlate-start-server t)

           (add-hook 'TeX-after-compilation-finished-functions
                     #'TeX-revert-document-buffer)

           (add-hook 'pdf-view-mode-hook
                     (lambda() (nlinum-mode -1))))

    :bind (:map pdf-view-mode-map
                ("h" . pdf-annot-add-highlight-markup-annotation)
                ("t" . pdf-annot-add-text-annotation)
                ("D" . pdf-annot-delete)))


  (custom-set-variables
   '(TeX-source-correlate-method 'synctex)
   '(TeX-source-correlate-mode t)
   '(TeX-source-correlate-start-server t))
#+END_SRC
* Startup
#+SRC_NAME LaTeX_config_start_notification
#+BEGIN_SRC emacs-lisp
  (message "Loading LaTeX configuration...")
#+END_SRC
** Update Environment
AucTeX 11.88.9 and beyond check that TeX binaries exist in the =exec-path= (in
addition to the path), which is important for a number of pieces of AucTeX
functionality in addition to compilation functions (like =TeX-doc=). (Having it
in the system's =PATH= alone is not enough.) On OS X El Capitan and beyond, we
update this variable to pass this test (using the symbolic link to
=/Library/TeX/texbin= provided by MacTeX/TeXLive to avoid priviledge issues with
=/usr/local=).
#+SRC_NAME Add_texbin_to_exec-path_on_macOS
#+BEGIN_SRC emacs-lisp :tangle no
  (when (eq system-type 'darwin)
    (add-to-list 'exec-path "/Library/TeX/texbin" t))
#+END_SRC
** Load AucTeX
AucTeX is the bread-and-butter LaTeX editor for Emacs and should always be
enabled to complement the built-in modes.

#+SRC_NAME auctex_use-package
#+BEGIN_SRC emacs-lisp
    (use-package tex :ensure auctex)
#+END_SRC
** AUCTeX Initialization/Configuration
*** Parse Document on Load and Save
#+BEGIN_SRC emacs-lisp
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
#+END_SRC

*** Multi-file Document Support
Make AUCTeX search for a master file instead of assuming it's the
current file.

#+BEGIN_SRC emacs-lisp
  (setq-default TeX-master nil)
#+END_SRC

** RefTeX Initialization/Configuration
*** Enable RefTeX in AUCTeX
First, we turn on RefTeX for AUCTeX http://www.gnu.org/s/auctex/manual/reftex/reftex_5.html
#+BEGIN_SRC emacs-lisp
  (add-hook 'TeX-mode-hook 'turn-on-reftex)
  (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
#+END_SRC
*** Add Custom Keybindings
#+BEGIN_SRC emacs-lisp
  (setq reftex-label-alist '((nil ?e nil "~\\eqref{%s}" nil nil)))
#+END_SRC
*** Set Default Bibliography
#+BEGIN_SRC emacs-lisp
  (setq reftex-default-bibliography
          '("~/workspace/citations/library.bib"))
#+END_SRC
** PreviewLaTeX
Preview LaTeX Mode allows you to preview the output of a LaTeX file in
a split-window environment. I currently don't enable it by default,
since I've been using Skim/external viewers instead.
#+BEGIN_SRC emacs-lisp :tangle no
  (load "preview-latex.el" nil t t)
#+END_SRC
* General Settings
** Ensure binaries are in =PATH= and =exec-path=
#+SRC_NAME latex_add-binaries
#+BEGIN_SRC emacs-lisp
  (setenv "PATH" (concat "/usr/texbin" ":"
                         "/usr/local/bin" ":"
                         (getenv "PATH")))
  (setq exec-path (append exec-path '("/usr/local/bin")))
#+END_SRC
** Enable "Advanced" Commands
As was the case in [[file:~/.emacs.d/init.org::*Enable%20"Advanced"%20Commands][my global settings]], I always enable some of the
non-beginner-friendly AucTeX commands that I use regularly.
#+SRC_NAME latex-mode_re-enable_advanced_commands
#+BEGIN_SRC emacs-lisp
  (put 'LaTeX-narrow-to-environment 'disabled nil)
#+END_SRC
* Editor Features
** Code Folding
Enabling [[help:outline-minor-mode][=outline-minor-mode=]] allows us to fold sections/environments akin to
the way we do so in Org Mode.
*** Add outline-minor-mode to (La)TeX hooks
#+SRC_NAME enable_outline-minor-mode_in_TeX-mode_and_LaTeX-mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'TeX-mode-hook #'outline-minor-mode)
  (add-hook 'LaTeX-mode-hook #'outline-minor-mode)
#+END_SRC
*** Configure sane keybindings for outline-minor-mode
*** Configure sane keybindings for outline-minor-mode              :hydras:
By default the prefix for outline-minor-mode is the insanely
inconvenient C-c @, so we change it to M-o instead. We also add
suffixes for just about every command we could ask for.
#+SRC_NAME outline-minor-mode_keymap_configuration
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-outline (:color blue :hint nil)
    "
  ^Hide^             ^Show^           ^Move
  ^^^^^^------------------------------------------------------
  _h_: _h_ide menu     _s_: _s_how menu   _u_: up (parent)
                                  _n_: next
  _q_: sublevels     _a_: all         _p_: previous
  _t_: body          _e_: entry
  _o_: other         _i_: children    _f_: forward sibling
  _c_: entry         _k_: branches    _b_: backward sibling
  _l_: leaves        _S_: subtree
  _d_: subtree

  "
    ;; Hiding things
    ("h" hydra-outline/hide/body)
    ("q" hide-sublevels)    ;
    ("t" hide-body)         ;
    ("o" hide-other)        ; Hide other branches
    ("c" hide-entry)        ; Hide this entry's body
    ("l" hide-leaves)       ; Hide body lines in this entry and sub-entries
    ("d" hide-subtree)      ; Hide everything in this entry and sub-entries

    ;; Showing things
    ("s" hydra-outline/show/body)
    ("a" show-all)          ; Show (expand) everything
    ("e" show-entry)        ; Show this heading's body
    ("i" show-children)     ; Show this heading's immediate child sub-headings
    ("k" show-branches)     ; Show all sub-headings under this heading
    ("S" show-subtree)      ; Show (expand) everything in this heading & below

    ;; Movement
    ("u" outline-up-heading)                ; Up
    ("n" outline-next-visible-heading)      ; Next
    ("p" outline-previous-visible-heading)  ; Previous
    ("f" outline-forward-same-level)        ; Forward - same level
    ("b" outline-backward-same-level)       ; Backward - same level
    ("z" nil "leave")

    ;; Hiding things
    ("M-h" hydra-outline/hide/body)
    ("M-q" hide-sublevels)    ;
    ("M-t" hide-body)         ;
    ("M-o" hide-other)        ; Hide other branches
    ("M-c" hide-entry)        ; Hide this entry's body
    ("M-l" hide-leaves)       ; Hide body lines in this entry and sub-entries
    ("M-d" hide-subtree)      ; Hide everything in this entry and sub-entries

    ;; Showing things
    ("M-s" hydra-outline/show/body)
    ("M-a" show-all)          ; Show (expand) everything
    ("M-e" show-entry)        ; Show this heading's body
    ("M-i" show-children)     ; Show this heading's immediate child sub-headings
    ("M-k" show-branches)     ; Show all sub-headings under this heading
    ("M-S" show-subtree)      ; Show (expand) everything in this heading & below

    ;; Movement
    ("M-u" outline-up-heading)                ; Up
    ("M-n" outline-next-visible-heading)      ; Next
    ("M-p" outline-previous-visible-heading)  ; Previous
    ("M-f" outline-forward-same-level)        ; Forward - same level
    ("M-b" outline-backward-same-level)       ; Backward - same level
    ("M-z" nil "leave"))


  (defhydra hydra-outline/hide (:color blue :hint nil)
  "
  ^Hide^
  ^^^^^^
  _S_: Hide all _S_ubheadings (and bodies)
  _B_: Hide all _B_odies (everything but headings) (hides _L_eaves in all trees)
  _O_: Hide all _O_ther branches (everything but current tree)

  _e_: Hide _c_urrent _e_ntry's _b_ody
  _l_: Hide all _l_eaves (bodies in subtree)
  _s_: Hide _s_ubtree

  "
  ("S" outline-hide-sublevels)
  ("B" outline-hide-body)
  ("L" outline-hide-body)
  ("O" outline-hide-other)

  ("e" outline-hide-entry)
  ("c" outline-hide-entry)
  ("b" outline-hide-entry)
  ("l" outline-hide-leaves)
  ("s" outline-hide-subtree)

  ("M-S" outline-hide-sublevels)
  ("M-B" outline-hide-body)
  ("M-L" outline-hide-body)
  ("M-O" outline-hide-other)

  ("M-e" outline-hide-entry)
  ("M-c" outline-hide-entry)
  ("M-b" outline-hide-entry)
  ("M-l" outline-hide-leaves)
  ("M-s" outline-hide-subtree))

  (defhydra hydra-outline/show (:color blue :hint nil)
  "
  ^Show^
  ------
  _A_: _a_ll

  _e_: _c_urrent _e_ntry's _b_ody
  _C_: _C_hildren
  _B_: _B_ranches
  _s_: _s_ub_t_ree (starting at point)

  "
  ("A" outline-show-all)
  ("a" outline-show-all)

  ("e" outline-show-entry)
  ("c" outline-show-entry)
  ("b" outline-show-entry)
  ("C" outline-show-children)
  ("B" outline-show-branches)
  ("s" outline-show-subtree)
  ("t" outline-show-subtree)

  ("M-A" outline-show-all)
  ("M-a" outline-show-all)

  ("M-e" outline-show-entry)
  ("M-c" outline-show-entry)
  ("M-b" outline-show-entry)
  ("M-C" outline-show-children)
  ("M-B" outline-show-branches)
  ("M-s" outline-show-subtree)
  ("M-t" outline-show-subtree))

  (global-set-key "\M-o" 'hydra-outline/body)

  ;; ; Outline-minor-mode key map
  ;; (define-prefix-command 'drmrd/LaTeX/outline-minor-mode-map nil "Outline-")

  ;; ; HIDE
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "q" 'outline-hide-sublevels)
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "\M-q" 'outline-hide-sublevels)

  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "t" 'outline-hide-body)
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "\M-t" 'outline-hide-body)

  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "o" 'outline-hide-other)
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "\M-o" 'outline-hide-other)

  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "c" 'outline-hide-entry)
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "\M-c" 'outline-hide-entry)

  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "l" 'outline-hide-leaves)
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "\M-l" 'outline-hide-leaves)

  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "d" 'outline-hide-subtree)
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "\M-d" 'outline-hide-subtree)

  ;; ; SHOW
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "a" 'outline-show-all)
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "\M-a" 'outline-show-all)
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "e" 'outline-show-entry)
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "\M-e" 'outline-show-entry)
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "i" 'outline-show-children)
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "\M-i" 'outline-show-children)
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "k" 'outline-show-branches)
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "\M-k" 'outline-show-branches)
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "s" 'outline-show-subtree)
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "\M-s" 'outline-show-subtree)

  ;; ; MOVE
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "u" 'outline-up-heading)
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "\M-u" 'outline-up-heading)
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "n" 'outline-next-visible-heading)
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "\M-n" 'outline-next-visible-heading)
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "p" 'outline-previous-visible-heading)
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "\M-p" 'outline-previous-visible-heading)
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "f" 'outline-forward-same-level)
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "\M-f" 'outline-forward-same-level)
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "b" 'outline-backward-same-level)
  ;; (define-key drmrd/LaTeX/outline-minor-mode-map "\M-b" 'outline-backward-same-level)
  ;; (global-set-key "\M-o" drmrd/LaTeX/outline-minor-mode-map)
#+END_SRC
**** TODO Move to init.org
*** Load outline-magic and bind outline-cycle to C-tab
This allows for org-like cycling of folded regions. Note the =:after=
keyword in the use-package call ensures that outline-magic is only
loaded after outline. This is the (MUCH) cleaner version of the old
=(eval-after-load 'outline '(progn [code for loading outline-magic]))=
construct!
#+BEGIN_SRC emacs-lisp
  (use-package outline-magic
      :after outline
      :bind ("C-<tab>" . outline-cycle))
#+END_SRC

*** Adding extra outline headings
In [[http://emacs.stackexchange.com/a/3076/8643][a brilliant answer]] on Emacs.SE, a most-excellently-named user
described some of his configuration. In particular, for adding fake
sections to his documents (i.e., headings that indicate to auctex
(and, hence, outline-minor-mode) the start of something section-like,
but things that are not compiled by LaTeX (comments)), and I'm dead
set on trying this out. Frankly, I can't believe I hadn't thought of
this myself!
#+BEGIN_SRC emacs-lisp
  ;; Extra outline headers
  (setq TeX-outline-extra
        '(
          ;; Fake preamble headers
          ("^\\s-*%meta" 1) ; for code sections (e.g., Local Variables)
          ("^\\s-*%psection" 2)
          ("^\\s-*%psubsection" 3)

          ;; Fake body headers
          ("^\\s-*%chapter" 1)
          ("^\\s-*%section" 2)
          ("^\\s-*%subsection" 3)
          ("^\\s-*%subsubsection" 4)
          ("^\\s-*%paragraph" 5)
          ("^\\s-*%proof" 5)))

  (add-hook 'LaTeX-mode-hook
            (lambda ()
              ;; Add font locking to the fake preamble headers
              (font-lock-add-keywords
               'latex-mode
               '(("^\\s-*\\(%\\(meta\\|psection\\|psubsection\\)\\)"
                  1 'font-lock-keyword-face t)
                 ("^\\s-*%meta{\\(.*\\)}" 'font-latex-sectioning-1-face t)
                 ("^\\s-*%psection{\\(.*\\)}" 'font-latex-sectioning-2-face t)
                 ("^\\s-*%psubsection{\\(.*\\)}" 'font-latex-sectioning-3-face t)))

              ;; Add font locking to the fake headers
              (font-lock-add-keywords
               'latex-mode
               '(("^\\s-*\\(%\\(chapter\\|\\(\\(sub\\)\\{0,4\\}\\)?section\\|paragraph\\|proof\\)\\)"
                  1 'font-lock-keyword-face t)

                 ("^\\s-*%chapter{\\(.*\\)}"       1 'font-latex-sectioning-1-face t)
                 ("^\\s-*%section{\\(.*\\)}"       1 'font-latex-sectioning-2-face t)
                 ("^\\s-*%subsection{\\(.*\\)}"    1 'font-latex-sectioning-3-face t)
                 ("^\\s-*%subsubsection{\\(.*\\)}" 1 'font-latex-sectioning-4-face t)
                 ("^\\s-*%subsubsubsection{\\(.*\\)}" 1 'font-latex-sectioning-4-face t)
                 ("^\\s-*%paragraph{\\(.*\\)}"     1 'font-latex-sectioning-5-face t)
                 ("^\\s-*%proof{\\(.*\\)}"         1 'font-latex-sectioning-5-face t)))))
#+END_SRC
**** TODO Consider expanding on this
For instance, we could add support for TODO comments that appear like
the ones in Org.
** Soft Line Wrapping
*** Navigate soft-wrapped lines visually
=visual-line-mode= is a WYSIWYG mode for Emacs's navigation keybindings, which
binds keys like =C-f=, =C-e=, and =C-k= to new commands that respect
soft-wrapping (and, hence, the visually-displayed line instead of the logical
line you are on in the current file).

#+SRC_NAME enable_visual-line-mode_in_TeX-mode_and_LaTeX-mode
#+BEGIN_SRC emacs-lisp
  (dolist (hook '(TeX-mode-hook LaTeX-mode-hook))
    (add-hook hook #'visual-line-mode))
#+END_SRC

*** Continue indentation level on soft-wrapped lines
By default Emacs does not preserve indentation on softly-wrapped lines. For
instance, suppose you had the following text in a buffer:

#+NAME: soft-wrapping_indentation_example__no_wrapping_whatsoever
#+BEGIN_EXAMPLE
  This is a paragraph talking about something. As the paragraph continues, it becomes clear that we should provide an example of what we're talking about to the dear reader. Our imaginary markup language visually emphasizes indented blocks differently than their unindented counterparts, so we provide the example as follows:

      This is our example. It is longer than sixty characters in length, and then some. In fact, it is longer than twice that length, if I am not mistaken. And I rarely am about line lengths, since I have a convenient column indicator in my mode line. In fact, goodness me, we're far past twice sixty, steadily encroaching on six times that length!

  Following this example, we continue our discussion here in another paragraph. It's just as relevant as the previous one. If you're still reading what might as well be lorem ipsum at this point, kudos.
#+END_EXAMPLE

In a window that is only sixty characters in width, this text will be
soft-wrapped as follows by default:

#+NAME: soft-wrapping_indentation_example__no_adaptive-wrap-prefix-mode
#+BEGIN_EXAMPLE
  This is a paragraph talking about something. As the
  paragraph continues, it becomes clear that we should provide
  an example of what we're talking about to the dear
  reader. Our imaginary markup language visually emphasizes
  indented blocks differently than their unindented
  counterparts, so we provide the example as follows:

      This is our example. It is longer than sixty characters
  in length, and then some. In fact, it is longer than twice
  that length, if I am not mistaken. And I rarely am about
  line lengths, since I have a convenient column indicator in
  my mode line. In fact, goodness me, we're far past twice
  sixty, steadily encroaching on six times that length!

  Following this example, we continue our discussion here in
  another paragraph. It's just as relevant as the previous
  one. If you're still reading what might as well be lorem
  ipsum at this point, kudos.
#+END_EXAMPLE

As you can see, the built-in soft-wrapping in Emacs at best leaves much to be
desired in terms of preserving the syntactic meaning of a buffer's context. In
fact it has already potentially introduced syntactic ambiguity: is the second
paragraph in the soft-wrapped text an indented paragraph or a soft-wrapped,
indented example?

Compare this to the output of =fill-region= (or an equivalent auto-filling,
hard-wrapping command) operating on the original buffer:

#+BEGIN_EXAMPLE
  This is a paragraph talking about something. As the
  paragraph continues, it becomes clear that we should provide
  an example of what we're talking about to the dear
  reader. Our imaginary markup language visually emphasizes
  indented blocks differently than their unindented
  counterparts, so we provide the example as follows:

      This is our example. It is longer than sixty characters
      in length, and then some. In fact, it is longer than
      twice that length, if I am not mistaken. And I rarely am
      about line lengths, since I have a convenient column
      indicator in my mode line. In fact, goodness me, we're
      far past twice sixty, steadily encroaching on six times
      that length!

  Following this example, we continue our discussion here in
  another paragraph. It's just as relevant as the previous
  one. If you're still reading what might as well be lorem
  ipsum at this point, kudos.
#+END_EXAMPLE

Here the indented example syntax remains clear but only at the potential cost of
losing semantic meaning. Imagine, for instance, that we'd placed each sentence
in our example text onto its own line originally. This is not so far-fetched,
since it's what I do when writing in version-controlled LaTeX files. It has the
advantage of allowing parsers to easily perform sentence-level transformations
to text and also can prove invaluable when =diff=ing the changes between two
versions of a paper. Hard-wrapping a region in a buffer obliterates this
semantic information (/i.e./, the demarcation of the beginning and end of each
sentence).

This is just one of the many semantically-destructive aspects of hard-wrapping
lines in text (prose or otherwise) that compel me to prefer efficient
indentation-manipulating commands coupled with smart soft-wrapping over the
convenience of =auto-fill-mode=. So far, by "smart" I mean "capable of
preserving indentation on soft-wrapped lines and respecting the =fill-column=.
We enable [[help:adaptive-wrap-prefix-mode][=adaptive-wrap-prefix-mode=]] to achieve the former.

#+SRC_NAME adaptive-wrap-prefix-mode_use-package
#+BEGIN_SRC emacs-lisp
  (use-package adaptive-wrap :ensure t
    :init (add-hook 'visual-line-mode-hook 'adaptive-wrap-prefix-mode))
#+END_SRC

Likewise, we enable =visual-fill-column-mode= whenever =visual-line-mode= is
active to soft-wrap buffers at the current =fill-column=. See [[http://melpa.org/#/visual-fill-column][here]] for
=visual-fill-column-mode='s MELPA documentation page. It's a small minor mode
that does this one thing and this one thing quite well. More conventional
implementations of soft line wrapping at a fixed column could be somewhat
buggy.

#+SRC_NAME visual-fill-column_use-package
#+BEGIN_SRC emacs-lisp
  (use-package visual-fill-column :ensure t
    :init (global-visual-fill-column-mode))
#+END_SRC

** LaTeX Math Mode
Load [[help:LaTeX-math-mode][LaTeX Math Mode]] by default. This is usually bound to 'C-c ~' (and
can still be toggled using that keybinding, but it's useful enough to
enable it outright).

#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
#+END_SRC

With this mode activated, pressing ` followed by a symbol will execute
a specific command as defined in the [[help:LaTeX-math-list][LaTeX-math-list]] alist (or one of
the built-in expansions. As explained in the documentation each
element of LaTeX-math-list is a list of the form
(KEY VALUE [opt: MENU CHARACTER]) for
 * KEY: a key such that `KEY will be replaced by VALUE
   - Can be nil, if you just want the VALUE to appear in the specified
     menu(s) but not bound to some `KEY
 * VALUE: the desired replacement string or a function to be called(!)
 * MENU: a string (e.g., "Greek"), list of strings (e.g., ("AMS"
   "Delimiters")), or nil, specifying which menu(s) this key/value
   should appear in. No menu items are created if this is nil.
 * CHARACTER: A unicode character to be displayed in the menu (can be
   nil if none is desired/applicable).
Note that this works with [[info:emacs#Init%20Syntax][all characters]], including "shifted"
characters like '?\C-a' or '?\M-b', if you use the correct syntax.
#+BEGIN_SRC emacs-lisp tangle: no
    (setq LaTeX-math-list '((?c "cong ")))
#+END_SRC
** Projectile Mode
Load =projectile= for project management.
#+BEGIN_SRC emacs-lisp
  (add-hook 'TeX-mode-hook #'projectile-mode)
  (add-hook 'LaTeX-mode-hook #'projectile-mode)
#+END_SRC
** ispell Mode
Note that the =ispell-tex-arg-end= function I mention below is defined
in =ispell.el= as follows.
#+BEGIN_SRC emacs-list :tangle no
  (defun ispell-tex-arg-end (&optional arg)
    "Skip across ARG number of braces."
    (condition-case nil
        (progn
          (while (looking-at "[ \t\n]*\\[") (forward-sexp))
          (forward-sexp (or arg 1)))
      (error
       (message "Error skipping s-expressions at point %d." (point))
       (beep)
       (sit-for 2))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;;; Per the documentation, `ispell-tex-skip-alists' is a list of two
  ;;; alists, each of these themselves being lists of 2- and 3-
  ;;; tuples. The tuples are all of the form
  ;;;     (BEGINREGEX ENDFUNCTION &optional BRACESCOUNT)
  ;;; where `BEGINREGEX' (the "key" referred to in this variable's
  ;;; documentation) is the regular expression (as a string) to match at
  ;;; the beginning of the region we want ispell to skip over,
  ;;; `ENDFUNCTION' is a function that moves the point forward to the
  ;;; end of the region we wish to skip. The optional argument
  ;;; `BRACESCOUNT' is a numeric argument passed to `ENDFUNCTION',
  ;;; which, for the built-in `ENDFUNCTION' (always
  ;;; `ispell-tex-arg-end') states the number of sexps to skip,
  ;;; defaulting to 1. The `ispell-tex-arg-end' function normally just
  ;;; moves past all optional arguments in the tex command, skips
  ;;; max(1,`BRACESCOUNT') matched sets of {}'s, and returns, catching
  ;;; any errors along the way. AFAICT, specifying a different value of
  ;;; `ENDFUNCTION' should just handle finding the end of the region to
  ;;; skip in a different manner without any side effects. That said,
  ;;; use at your own risk, since the source's documentation is pretty
  ;;; terrible.
  ;;;
  ;;; Actually, it looks like BOTH `BEGINREGEX' and `ENDFUNCTION' can be
  ;;; regular expressions (given as strings) and/or functions!  The
  ;;; result of each should be to move the mark to wherever you damn
  ;;; well please.
  ;;;
  ;;; The difference between the first and second entries in
  ;;; `ispell-tex-skip-alists' is that each `BEGINREGEX' inside the
  ;;; second list is matched from within a \begin{...} environment
  ;;; delimiter.  Haven't looked into how this affects the behavior of
  ;;; `ENDFUNCTION', but from the source of `ispell-tex-arg-end', the
  ;;; regexs used for `ENDFUNCTION' in the default value of
  ;;; `ispell-tex-skip-alists', and a brief read through function that
  ;;; loads the latter in `ispell.el', my guess is that `ENDFUNCTION'
  ;;; behavior is totally unaffected. (So you should look for an end
  ;;; block if you want to skip the entirety of an environment, not,
  ;;; e.g., just the environment name.)
  ;;;
  ;;; Note: `ispell-tex-arg-end' passes (or `BRACESCOUNT' 1) to
  ;;; `forward-sexp', so specifying `BRACESCOUNT' to 0 does have the
  ;;; expected effect of *only* skipping optional arguments. This is
  ;;; useful, for instance, when wanting to skip the arguments of a
  ;;; table environment (where there are never things to spellcheck),
  ;;; but you don't want to skip the table's contents.
  (setq ispell-tex-skip-alists
        (list (append (car ispell-tex-skip-alists)
                      '(("\\\\def\\\\" . ispell-tex-arg-end)))
              ;; Feel free to append to the 2nd alist, too. I've no use
              ;; for it at the moment, so it's just going back as is. Of
              ;; course, this means this whole command is rather
              ;; unnecessarily verbose for the time being. But hey, it's
              ;; readable and ready for extension.
              (cdr ispell-tex-skip-alists)))
#+END_SRC
** Save Place Mode                  :save_place_mode:Persistence:Navigation:
When opening a file, Save Place Mode restores the point to the last place it
appeared in a buffer containing the file. For each tracked file, point locations
are stored in the =save-place-file=, which defaults to =.emacs.d/places= for
Emacs versions 25.1+. While =save-place-mode= is global, storing file positions
for every file you open in Emacs, you can be more selective with when this
occurs by turning on =save-place-local-mode= instead on a per file or major mode
basis.  #+SRC_NAME latex_hook_to_save-place-local-mode
#+BEGIN_SRC emacs-lisp
  (dolist (hook '(TeX-mode-hook LaTeX-mode-hook))
    (add-hook hook #'save-place-local-mode))
#+END_SRC
* Appearance
** Custom Syntax Highlighting
Syntax highlighting is controlled by Font Lock Mode, and it is a simple matter
to add additional keywords for it to recognize and color accordingly using the
[[help:font-lock-add-keywords][font-lock-add-keywords]] function. Keywords are passed to this function as a list
of elements of the form described [[help:font-lock-keywords][here]].

AucTeX, however, provides its own LaTeX-tailored keyword configuration variable
called [[help:font-latex-user-keyword-classes][font-latex-user-keyword-classes]]. It consists of a list of "keyword
classes", each of the form
#+SRC_NAME font-latex-user-keyword-classes_keyword_class_syntax
#+BEGIN_EXAMPLE emacs-lisp
  (<class> ((<keyword> <args>) ...) <face> <type>)
#+END_EXAMPLE
where =<class>=, =<keyword>=, and =<args>= are strings and both =face= and
=type= are (unquoted) symbols. (The pair =(<keyword> <args>)= can also just be a
simple string =<keyword>= if you don't care about highlighting arguments/the
macro takes no arguments/you like the default argument highlighting behavior.)
The =font-latex= package then handles setting up font-lock matchers for each
keyword in the class, including for its arguments thanks to its 'argument
string' (specified by =<arg>= above).

The example provided in the [[help:font-latex-user-keyword-classes][help page]] of an argument string for =\newcommand=
conveys the idea well. The correct entry in a keyword class for =\newcommand=
would look like =("newcommand" "*|{\[[{")=, where, character-by-character, the
string ="*|{\[[{"= indicates that
  - * :: =\newcommand= can be starred
  - | :: the next two characters form a pair of alternative arguments (/i.e./,
         either ={= or =\= will be the next argument).
  - { :: a mandatory argument (wrapped in ={= and =}=)
  - \ :: a mandatory argument that is a macro and not wrapped in braces
  - [ :: an optional argument
  - [ :: another optional argument
  - { :: a mandatory argument
Note the "Polish-style" use of =|= as a /prefix/ to the alternatives ={= and
=\=. I missed this when first reading the documentation.

#+NAME setup_font-latex-user-keyword-classes
#+BEGIN_SRC emacs-lisp :tangle no
  (with-eval-after-load "font-latex"
    (setq font-latex-user-keyword-classes
          '(("idxdefs"
             (("idxdef" "[{")
              ("NewIndexableMathObject" "{{{{{{"))
             bold command))))
#+END_SRC

#+SRC_NAME font-latex-match-reference-keywords_configuration
#+BEGIN_SRC emacs-lisp
  (setq font-latex-match-reference-keywords
        '(("indexed" "[{")
          ("autocites" "[[{[[{[[{[[{[[{[[{")
          ("autocites" "[[{[[{[[{[[{[[{")
          ("autocites" "[[{[[{[[{[[{")
          ("autocites" "[[{[[{[[{")
          ("autocites" "[[{[[{")
          ("compoundcref" "{{")))
#+END_SRC
* TODO Improving Help Commands
Wouldn't it be amazing if there was a =describe-latex-macro= command
for Emacs with the same functionality as =describe-function=? This is
a cool idea for a project that we should totally start working on.
* Customizing Environment Templates/Insertion Behavior
** Inserting Items with Alt + Ret                           :enumerate:item:
Within enumerate-like environments (in fact, at any point in a LaTeX
buffer), hitting [Alt] + [Return] invokes [[help:LaTeX-insert-item][LaTeX-insert-item]]
* Support for Custom Macros & Environments
** Make AUCTeX Aware of Custom Theorem Environments
#+SRC_NAME auctex_add_custom_environments
#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook
    (lambda ()
      (LaTeX-add-environments
        '("claim"      LaTeX-env-label)
        '("conjecture" LaTeX-env-label)
        '("convention" LaTeX-env-label)
        '("cor"        LaTeX-env-label)
        '("example"    LaTeX-env-label)
        '("lem"        LaTeX-env-label)
        '("note"       LaTeX-env-label)
        '("notation"   LaTeX-env-label)
        '("proof"      LaTeX-env-label)
        '("prop"       LaTeX-env-label)
        '("question"   LaTeX-env-label)
        '("rem"        LaTeX-env-label)
        '("thm"        LaTeX-env-label))))
#+END_SRC
** Make RefTeX aware of idxdef and indexdef indexing commands
Make RefTeX aware of our custom indexing commands and bind some of them to
keys. We also set =\indexed= to be the default indexing command in RefTeX, which
is bound to =C-c /=.
#+SRC_NAME set_reftex-index-macros
#+BEGIN_SRC emacs-lisp
  (add-hook 'reftex-mode-hook
            (lambda ()
              (setq reftex-index-macros
                    '(("\\indexed{*}" "idx" ?x "" nil nil)
                      ("\\idxdef{*}" "idx" ?d "" nil nil)
                      ("\\indexdef{*}" "idx" ?D "" nil nil)))
              (setq reftex-index-default-macro '(?x "idx"))))
#+END_SRC
*** TODO Create a RefTeX mode hydra, possibly bound to =C-c r=
There are so many amazing RefTeX mode commands I forget about that it's probably
worth collecting them somewhere.
** Support for NewIndexableMathObject & the macros it generates
#+SRC_NAME latex_NewIndexableMathObject_support
#+BEGIN_SRC emacs-lisp
  ;; % \NewIndexableMathObject{#1=ObjectName}{#2=Expansion}%
  ;; %                        {#3=IndexParent}{#4=SortKey}%
  ;; %                        {#5=IndexPrefix}{#6=IndexSuffix}
  ;; %
  ;; % Defines
  ;; %
  ;; %     1. A macro with name <ObjectName> and expansion <Expansion>.
  ;; %     2. A macro with name <ObjectName>SortKey and expansion <SortKey> for use
  ;; %        in calls to indexing macros. (This should be the string used by the
  ;; %        index to find the right lexicographic place for this object's entry in
  ;; %        the index.
  ;; %     3. A macro with name mention<ObjectName> that should be called at any
  ;; %        point in the text where this object is discussed/referenced that you'd
  ;; %        like included in the index.
  ;; %
  ;; % The <IndexParent> is the parent (or ancestors) of this object in the index.
  ;; % The <IndexPrefix> and <IndexSuffix> are math expressions (with or without
  ;; % dollar signs) that should be prepended and appended to <Expansion> in the
  ;; % index entry for the object. (For example, if you defined an object with
  ;; % expansion C_c^\infty, you might want to set <IndexSuffix> equal to (G).)
  ;; \newcommand{\NewIndexableMathObject}[6]{%
  ;;     \expandafter\newcommand\csname #1\endcsname{#2}
  ;;     \expandafter\newcommand\csname #1SortKey\endcsname{#4}
  ;;     \def\temp{#3}\ifx\temp\empty
  ;;         \def\indexParentString{\temp!}%
  ;;     \else
  ;;         \def\indexParentString{}%
  ;;     \fi
  ;;     \expandafter\newcommand\csname mention#1\endcsname{\expandafter\index{\indexParentString{}#4@\expandafter\ensuremath{#5\csname #1\endcsname#6}}}%
  ;; }

  ;; (defvar drmrd/LaTeX/macro-pattern/NewIndexableMathObject
  ;;   '("\\\\NewIndexableMathObject{\\([a-zA-Z]+\\)}" (1 2) TeX-auto-multi)
  ;;   "A regex matching \NewIndexableMathObject definitions.")

  ;; (defvar TeX-auto-multi nil
  ;;   "Temporary for parsing \\newmacro definitions.")

  ;; (defun TeX-macro-cleanup ()
  ;;   "Move symbols from `TeX-auto-multi' to `TeX-auto-symbol'."
  ;;   (mapcar (lambda (list)
  ;; 	    (mapcar (lambda (symbol)
  ;; 		      (setq TeX-auto-symbol
  ;; 			    (cons symbol TeX-auto-symbol)))
  ;; 		    list))
  ;; 	  TeX-auto-multi))

  ;; (defun TeX-macro-prepare ()
  ;;   "Clear `Tex-auto-multi' before use."
  ;;   (setq TeX-auto-multi nil))

  ;; (add-hook 'TeX-auto-prepare-hook 'TeX-macro-prepare)
  ;; (add-hook 'TeX-auto-cleanup-hook 'TeX-macro-cleanup)

  ;; (TeX-add-style-hook
  ;;  "macro"
  ;;  (lambda ()
  ;;    (TeX-auto-add-regexp TeX-newmacro-regexp)
  ;;    (TeX-add-symbols '("newmacro"
  ;; 		      TeX-arg-macro
  ;; 		      (TeX-arg-macro "Capitalized macro: \\")
  ;; 		      t
  ;; 		      "BibTeX entry: "
  ;; 		      nil))))
#+END_SRC
* Custom Functions
** TODO Forward/Backward Token/Mode/Environment Boundary Functions
By default, the key combinations 'C-M-f' and 'C-M-b' are bound to
[[help:forward-sexp][forward-sexp]] and [[help:backward-sexp][backward-sexp]], which aren't very useful in a TeX
document. We will instead bind these commands to functions that look
for the next/previous instance of a token delimiter: *{*; a math-mode
delimiter: *$*, *$$*, *\[$, or *\]$; or an environment *begin* or
*end* statement. We collectively call such things *LaTeX boundary
delimiters*, although reserve the right to change this name later.

#+SRC_NAME TeX-BoundaryDelimiters
#+BEGIN_SRC emacs-lisp :tangle no
  (defvar drmrd-init/lib/latex-TokenDelimiters
    '(("{" . nil)
      ("}" . nil))
    "An alist consisting of elements (CAR . CDR), in which CAR is
    always a string representing a (Whatever)Tex token
    delimiter. So, for instance, the default alist in a TeX or
    LaTeX distribution would include a string for matching '{' and
    another for matching '}'. In each list element, if CDR is
    non-nil treat CAR as a regular expression string and otherwise
    treat it like a string to be matched literally.")

  (defvar drmrd-init/lib/latex-MathDelimiters
    '(("$$" . nil)
      ("$" . nil)
      ("\\[" . nil)
      ("\\]" . nil))
    "An alist consisting of elements (CAR . CDR), in which CAR is
    always a string representing a (Whatever)Tex math mode
    delimiter (which is to say either an inline or displayed
    equation). So, for instance, the default alist in a TeX or
    LaTeX distribution would include strings for matching '$',
    '$$', '\[', and '\]'. In each list element, if CDR is non-nil
    treat CAR as a regular expression string and otherwise treat it
    like a string to be matched literally.")

  (defvar drmrd-init/lib/latex-EnvDelimiters
    '(("\\begin{\w+}" . t) ("\\end{\w+}" . t))
    "An alist consisting of pairs of elements (CAR . CDR), in which CAR
    is always a string representing a (Whatever)Tex environment
    beginning or ending delimiter (which is to say either an inline or
    displayed equation). So, for instance, the default alist in a LaTeX
    distribution would include strings for matching '\begin{<valid
    env-name>}' and '\end{<valid env-name>}'. In each list element, if
    CDR is non-nil treat CAR as a regular expression string and
    otherwise treat it like a string to be matched literally.")

  (defvar drmrd-init/lib/latex-BoundaryDelimiter
    (append drmrd-init/lib/latex-TokenDelimiters
            drmrd-init/lib/latex-MathDelimiters
            drmrd-init/lib/latex-EnvDelimiters)
    "The complete alist of 'LaTeX Boundary Delimiters' (delimiters
    of tokens, math modes, and environments) used, e.g., in
    conjunction with the `forward-LaTeX-boundary-delimiter'
    function. In each element (CAR . CDR), CAR is always a string
    representing a LaTeX boundary delimiter either as a string
    literal or an elisp regular expression string, with a non-nil
    CDR indicating that it is the latter.")


  (defun forward-LaTeX-boundary-delimiter (&optional arg)
    "Move forward to the next instance of a delimiter of a TeX
  token, math mode, or environment. With ARG, do it that many
  times.  Negative arg -N means find the N-th instance of such a
  delimiter in the backwards direction.  The definition of a LaTeX
  boundary delimiter may be configured by modifying the
  `drmrd-init/lib/latex-BoundaryDelimiter' variable."
    (interactive "^p") ; Recall that "^" makes this compatible with
                       ; shift selection and "p" converts the prefix
                       ; argument to a number if present.
    (or arg (setq arg 1)) ; Set `arg` equal to 1 if not provided.
    (goto-char (or (scan-latex-boundary-delimiters (point) arg) (buffer-end arg)))
    (if (< arg 0) (backward-prefix-chars)))

  (defun scan-latex-boundary-delimiters (from count)
    "Scan from character number FROM forward or backward depending
  on the sign of COUNT. Scan until |COUNT|
  LaTeX-boundary-delimiters have been found and return the
  character number of the |COUNT|-th delimiter. Returns nil if the
  beginning or end of (the accessible part of) the buffer is
  reached before |COUNT|-many matches are found."
    (sleep-for 1))
#+END_SRC


*** TODO Decide on a name for these functions
** Replace display math wrapper \[…\] with an environment
The following function adds a piece of functionality complementary AucTeX's that
I've been missing for some time.  I'd like to genericize it for other use
cases.  It's based on giordano's lovely [[https://tex.stackexchange.com/a/179306/14062][answer]] to a question on TeX.SE.
#+SRC_NAME drmrd/latex/displaymath->environment_defn
#+BEGIN_SRC emacs-lisp
  (defun drmrd/latex/displaymath<->align*-toggle ()
    "Swap between displayed math and an align* environment."
    (interactive)
    (save-excursion
      (when (texmathp)
        (cond
         ((equal (car texmathp-why) "\\[")
          (goto-char (cdr texmathp-why))
          (delete-char 2)
          (push-mark)
          (search-forward "\\]")
          (delete-char -2)
          (exchange-point-and-mark)
          (LaTeX-insert-environment "align*"))
         ((equal (car texmathp-why) "align*")
          (LaTeX-find-matching-begin)
          (re-search-forward "\\\\begin{align\\\*}")
          (replace-match "\\\\\[")
          (LaTeX-find-matching-end)
          (re-search-backward "\\\\end{align\\\*}")
          (replace-match "\\\\\]"))))))
#+END_SRC
* Indentation
** Set default indentation level to 4 spaces
#+BEGIN_SRC emacs-lisp
  (setq-default LaTeX-default-offset 4)
#+END_SRC
** Customize general indentation settings
#+BEGIN_SRC emacs-lisp
  ;;
  ;; Customizing general indentation settings
  ;;
  ; Set indentation of current line by 4n where n is the sum of the
  ; number of unmatched instances of "\begin{<environment>}" and "{":
  (setq-default LaTeX-indent-level 4)
  (setq-default TeX-brace-indent-level 4)
  ; Add 0m to indentation level of current line where m is the number
  ; currently-unmatched, enumerate-like environments at our current
  ; location (and the cursor is on a line beginning with "\item" or
  ; something "\item-like":
  (setq-default LaTeX-item-indent 0)
#+END_SRC
** Advise indent command to indent inside parts, chapters, sections, etc.
#+BEGIN_SRC emacs-lisp
  (defadvice LaTeX-indent-line (after LaTeX-indent-line-in-sections-advice activate)
    "A function designed to advise the indent command to indent within
     parts, chapters, sections, subsections, etc."
    (interactive)
    (let (
           (section-list ; Make a copy of LaTeX-section-headers
             (copy-list LaTeX-section-list)
           )
           (prevline ; Set equal to the previous line as a string
             (save-excursion
               (forward-line -1)
               (thing-at-point 'line t)
             )
           )
         )
         ; If the previous line is the start of a section, indent
         ; the current line by an additional LaTeX-default-offset
         ; spaces.
         ;
         ; The while loop essentially uses section-list, a copy of
         ; LaTeX-section-list, as a stack, pushing another section
         ; name off the stack with each iteration until it is empty.
         ;
         ; The entire while loop is wrapped in a save-excursion call
         ; to avoid moving the pointer around. I'm not sure if this
         ; is less efficient than just putting it in the conditional
         ; or if it matters at all. Perhaps something to look into
         ; another time.
         (save-excursion
           (while section-list
             (if (string-match (concat "\s-+\\" (caar section-list) ".*\s-") prevline)
               (progn
                 ; Move to first non-whitespace character in line
                 (back-to-indentation)
                 ; Insert LaTeX-default-offset many spaces
                 (indent-to 0 LaTeX-default-offset)
                 (setq section-list nil)
               )
             )
             (setq section-list (cdr section-list))
           )
         )
    )
  )
#+END_SRC
*** DONE Fix the interaction between this and environment insertion commands
CLOSED: [2015-12-05 Sat 14:27]
It seems that this advice may break environment insertion via C-c
C-e. The latter now places the "\end{...}" block immediately before
the "\begin{...}" one.
*** I've officially learned a trick or two!
Figuring out the "right" way to implement this in Emacs was daunting a
few months ago. Today (<2015-12-02 Wed>) I did it in 1.5 hours.
* Debugging
** Change TeX debugging mode (for more informative error messages)
#+BEGIN_SRC emacs-lisp
  (setq LaTeX-command-style '(("" "%(PDF)%(latex) -file-line-error %S%(PDFout)")))
#+END_SRC
* Compilation & External Programs
** Compile PDFs by Default
#+BEGIN_SRC emacs-lisp
  (setq TeX-PDF-mode t)
#+END_SRC
** Create Custom Compilation Commands (& Tweak Built-In Ones)
#+BEGIN_SRC emacs-lisp
    (defun drmrd/latex/string=-cars (cons1 cons2)
      "Determine if two cons are equal by comparing their cars as
      strings. The car comparison is done using `string='. No
      type-checking is performed before attempting to compare cons, so
      this can lead to unexpected outcomes if CONS1 and CONS2 are not
      lists (or if their cars are not strings)."
      (string= (car cons1) (car cons2)))
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook
    (lambda ()
      (add-to-list 'TeX-command-list
                   '("latexmk" "latexmk -outdir=./tmp %t -pdf %s"
                     TeX-run-TeX nil t :help "Run latexmk on file")
                   nil 'drmrd/latex/string=-cars)))
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook
    (lambda ()
      (add-to-list 'TeX-command-list
                   '("LaTeX+" "latexmk -auxdir=./tmp %t -pdf %s"
                     TeX-run-TeX nil t :help
                     "Run latexmk, storing temporary files in ./tmp")
                     nil 'drmrd/latex/string=-cars)))
#+END_SRC
** Enable support for latexmk via C-c C-c
#+BEGIN_SRC emacs-lisp

  ;(add-hook 'TeX-mode-hook '(lambda () (setq TeX-command-default "latexmk")))
#+END_SRC
** Set how TeX handles DVI files
#+BEGIN_SRC emacs-lisp
  (setq tex-dvi-print-command "dvips")
  (setq tex-dvi-view-command "xdvi")
#+END_SRC
** TODO Store temporary files in ./tmp
** Configure view programs                     :Viewing:Output:Evince:Okular:
This code could equally well be customized, since it's rather volatile or at
very least system dependent. The current version of this configuration is taken
from [[http://tex.stackexchange.com/a/150645][this TeX.SE answer]].
#+SRC_NAME auctex_set_TeX-view-program-list
#+BEGIN_SRC emacs-lisp
  ;; See [[help:TeX-expand-list-builtin][TeX-expand-list-builtin]] and
  ;; [[help:TeX-expand-list][TeX-expand-list]] for a complete list of the "%foo"
  ;; expansions appearing in the shell commands below.
  (eval-after-load "tex"
    (lambda ()
      (cl-case system-type

        ('gnu/linux
         (setq TeX-view-program-list      '(("Evince" "evince --page-index=%(outpage) %o")))
         (setq TeX-view-program-selection '((output-pdf "Evince"))))

        ('darwin
         ;; Use Skim as default PDF viewer
         ;; Skim's displayline is used for forward search (from .tex to .pdf)
         ;; Its -b option highlights the current line; option -g opens Skim in the
         ;; background
         (setq TeX-view-program-list
               '(("Skim" "/Applications/Skim.app/Contents/SharedSupport/displayline -b -g %n %o %b")
                 ("Preview" "open -a Preview.app %n")))
         (setq TeX-view-program-selection '((output-pdf "Skim")))))))

#+END_SRC
* Wrap Up
There is nothing to do here for the time being, but we'll at least
record that we've loaded the file successfully in the *Messages* buffer.
#+BEGIN_SRC emacs-lisp
  (message "Finished loading LaTeX configuration!")
#+END_SRC
