#+TITLE: LaTeX Emacs Configuration
#+AUTHOR: DRMRD
#+PROPERTY: header-args    :tangle ~/.emacs.d/lib/latex.el
#+OPTIONS: toc:nil num:nil ^:nil
#+STARTUP: indent

* latex.el Reference
** Determining the document structure at the current point
| Structure (@ Point) | Function                     |
|---------------------+------------------------------|
| Environment         | [[help:LaTeX-current-environment][LaTeX-current-environment]]    |
| Section             | [[help:LaTeX-current-section][LaTeX-current-section]]        |
| Indentation         | [[help:LaTeX-current-indentation][LaTeX-current-indentation]]    |
| Verbatim Macro      | [[help:LaTeX-current-verbatim-macro][LaTeX-current-verbatim-macro]] |
* Startup
** Load AucTeX and Preview LaTeX
AucTeX is the bread-and-butter LaTeX editor for Emacs and should
always be enabled to complement the built-in modes.

#+BEGIN_SRC emacs-lisp
  (sit-for 1)
  (message "Loading LaTeX configuration...")
  ; Don't try to load auctex.el. ELPA takes care of this
  ; (load "auctex.el" nil t t)
#+END_SRC

*** TODO Test whether the sit-for call is necessary
I no longer remember why I added that. Perhaps the problem has fixed
itself? Either way, this is why we document our config files,
children!
** AUCTeX Initialization/Configuration
*** Parse Document on Load and Save
#+BEGIN_SRC emacs-lisp
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
#+END_SRC

*** Multi-file Document Support
Make AUCTeX search for a master file instead of assuming it's the
current file.

#+BEGIN_SRC emacs-lisp
  (setq-default TeX-master nil)
#+END_SRC

** RefTeX Initialization/Configuration
*** Enable RefTeX in AUCTeX
First, we turn on RefTeX for AUCTeX http://www.gnu.org/s/auctex/manual/reftex/reftex_5.html
#+BEGIN_SRC emacs-lisp
  (add-hook 'TeX-mode-hook 'turn-on-reftex)
  (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
#+END_SRC
*** Add Custom Keybindings
#+BEGIN_SRC emacs-lisp
  (setq reftex-label-alist '((nil ?e nil "~\\eqref{%s}" nil nil)))
#+END_SRC
*** Set Default Bibliography
#+BEGIN_SRC emacs-lisp
  (setq reftex-default-bibliography
          '("~/workspace/citations/library.bib"))
#+END_SRC
** PreviewLaTeX
Preview LaTeX Mode allows you to preview the output of a LaTeX file in
a split-window environment. I currently don't enable it by default,
since I've been using Skim/external viewers instead.
#+BEGIN_SRC emacs-lisp :tangle no
  (load "preview-latex.el" nil t t)
#+END_SRC
* Configuring Minor Modes
** Outline Minor Mode
This allows us to fold sections/environments like in Org Mode.
*** Add outline-minor-mode to (La)TeX hooks
#+SRC_NAME enable_outline-minor-mode_in_TeX-mode_and_LaTeX-mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'TeX-mode-hook #'outline-minor-mode)
  (add-hook 'LaTeX-mode-hook #'outline-minor-mode)
#+END_SRC
*** Configure sane keybindings for outline-minor-mode
By default the prefix for outline-minor-mode is the insanely
inconvenient C-c @, so we change it to M-o instead. We also add
suffixes for just about every command we could ask for.
#+BEGIN_SRC emacs-lisp
  ; Outline-minor-mode key map
  (define-prefix-command 'cm-map nil "Outline-")
  ; HIDE
  (define-key cm-map "q" 'hide-sublevels)    ; Hide everything but the top-level headings
  (define-key cm-map "\M-q" 'hide-sublevels)
  (define-key cm-map "t" 'hide-body)         ; Hide everything but headings (all body lines)
  (define-key cm-map "\M-t" 'hide-body)
  (define-key cm-map "o" 'hide-other)        ; Hide other branches
  (define-key cm-map "\M-o" 'hide-other)
  (define-key cm-map "c" 'hide-entry)        ; Hide this entry's body
  (define-key cm-map "\M-c" 'hide-entry)
  (define-key cm-map "l" 'hide-leaves)       ; Hide body lines in this entry and sub-entries
  (define-key cm-map "\M-l" 'hide-leaves)
  (define-key cm-map "d" 'hide-subtree)      ; Hide everything in this entry and sub-entries
  (define-key cm-map "\M-d" 'hide-subtree)
  ; SHOW
  (define-key cm-map "a" 'show-all)          ; Show (expand) everything
  (define-key cm-map "\M-a" 'show-all)
  (define-key cm-map "e" 'show-entry)        ; Show this heading's body
  (define-key cm-map "\M-e" 'show-entry)
  (define-key cm-map "i" 'show-children)     ; Show this heading's immediate child sub-headings
  (define-key cm-map "\M-i" 'show-children)
  (define-key cm-map "k" 'show-branches)     ; Show all sub-headings under this heading
  (define-key cm-map "\M-k" 'show-branches)
  (define-key cm-map "s" 'show-subtree)      ; Show (expand) everything in this heading & below
  (define-key cm-map "\M-s" 'show-subtree)
  ; MOVE
  (define-key cm-map "u" 'outline-up-heading)                ; Up
  (define-key cm-map "\M-u" 'outline-up-heading)
  (define-key cm-map "n" 'outline-next-visible-heading)      ; Next
  (define-key cm-map "\M-n" 'outline-next-visible-heading)
  (define-key cm-map "p" 'outline-previous-visible-heading)  ; Previous
  (define-key cm-map "\M-p" 'outline-previous-visible-heading)
  (define-key cm-map "f" 'outline-forward-same-level)        ; Forward - same level
  (define-key cm-map "\M-f" 'outline-forward-same-level)
  (define-key cm-map "b" 'outline-backward-same-level)       ; Backward - same level
  (define-key cm-map "\M-b" 'outline-backward-same-level)
  (global-set-key "\M-o" cm-map)
#+END_SRC
**** TODO Move to init.org
*** Load outline-magic and bind outline-cycle to C-tab
This allows for org-like cycling of folded regions. Note the =:after=
keyword in the use-package call ensures that outline-magic is only
loaded after outline. This is the (MUCH) cleaner version of the old
=(eval-after-load 'outline '(progn [code for loading outline-magic]))=
construct!
#+BEGIN_SRC emacs-lisp
  (use-package outline-magic
      :after outline
      :bind ("C-<tab>" . outline-cycle))
#+END_SRC

*** Adding extra outline headings
In [[http://emacs.stackexchange.com/a/3076/8643][a brilliant answer]] on Emacs.SE, a most-excellently-named user
described some of his configuration. In particular, for adding fake
sections to his documents (i.e., headings that indicate to auctex
(and, hence, outline-minor-mode) the start of something section-like,
but things that are not compiled by LaTeX (comments)), and I'm dead
set on trying this out. Frankly, I can't believe I hadn't thought of
this myself!
#+BEGIN_SRC emacs-lisp
  ;; extra outline headers
  (setq TeX-outline-extra
        '(("%chapter" 1)
          ("%section" 2)
          ("%subsection" 3)
          ("%subsubsection" 4)
          ("%paragraph" 5)
          ("%proof" 5)))

  ;; add font locking to the headers
  (font-lock-add-keywords
   'latex-mode
   '(("^%\\(chapter\\|\\(sub\\|subsub\\)?section\\|paragraph\\|proof\\)"
      0 'font-lock-keyword-face t)
     ("^\\s-*%chapter{\\(.*\\)}"       1 'font-latex-sectioning-1-face t)
     ("^\\s-*%section{\\(.*\\)}"       1 'font-latex-sectioning-2-face t)
     ("^\\s-*%subsection{\\(.*\\)}"    1 'font-latex-sectioning-3-face t)
     ("^\\s-*%subsubsection{\\(.*\\)}" 1 'font-latex-sectioning-4-face t)
     ("^\\s-*%paragraph{\\(.*\\)}"     1 'font-latex-sectioning-5-face t)
     ("^\\s-*%proof{\\(.*\\)}"         1 'font-latex-sectioning-5-face t)))
#+END_SRC
**** TODO Consider expanding on this
For instance, we could add support for TODO comments that appear like
the ones in Org.
** Visual Line Mode
A WYSIWYG mode for Emacs's navigation keybindings, which binds keys
like C-f, C-e, and C-k to new commands that respect soft-wrapping
(and, hence, the visually-displayed line instead of the logical line
you are on in the current file).

As we should have been doing from the beginning in our config files,
we begrudgingly define a visual-line-mode-on function that ensures the
mode is active and then add that to the relevant hooks. This is to
ensure backwards compatibility, e.g., with the pre-v24.1 Emacsen I
encounter regularly. If by some wonderful twist of fate I eventually
only ever work with v24.1 and above, then this can simply be changed
to (add-hook 'relevant-mode-hook #'visual-line-mode) (note the
function-quoting #' used on the function symbol to allow for byte
compilation).
#+SRC_NAME enable_visual-line-mode_in_TeX-mode_and_LaTeX-mode
#+BEGIN_SRC emacs-lisp
  (dolist (hook '(TeX-mode-hook LaTeX-mode-hook))
    (add-hook hook #'visual-line-mode))
#+END_SRC
*** TODO Consider using visual-fill-column to wrap at a fixed column
See [[http://melpa.org/#/visual-fill-column][here]] for its MELPA documentation page. It's a small minor mode
that does this one thing and this one thing quite well. More
convention implementations of soft line wrapping at a fixed column
could be somewhat buggy.
** Adaptive Wrap Prefix Mode
#+BEGIN_SRC emacs-lisp
  (defun adaptive-wrap-prefix-mode-on()
    "Turn on `adaptive-wrap-prefix-mode' minor mode."
    (interactive)
    (adaptive-wrap-prefix-mode 1))
  (add-hook 'TeX-mode-hook #'adaptive-wrap-prefix-mode-on)
  (add-hook 'LaTeX-mode-hook #'adaptive-wrap-prefix-mode-on)
#+END_SRC
** LaTeX Math Mode
Load [[help:LaTeX-math-mode][LaTeX Math Mode]] by default. This is usually bound to 'C-c ~' (and
can still be toggled using that keybinding, but it's useful enough to
enable it outright).

#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
#+END_SRC

With this mode activated, pressing ` followed by a symbol will execute
a specific command as defined in the [[help:LaTeX-math-list][LaTeX-math-list]] alist (or one of
the built-in expansions. As explained in the documentation each
element of LaTeX-math-list is a list of the form
(KEY VALUE [opt: MENU CHARACTER]) for
 * KEY: a key such that `KEY will be replaced by VALUE
   - Can be nil, if you just want the VALUE to appear in the specified
     menu(s) but not bound to some `KEY
 * VALUE: the desired replacement string or a function to be called(!)
 * MENU: a string (e.g., "Greek"), list of strings (e.g., ("AMS"
   "Delimiters")), or nil, specifying which menu(s) this key/value
   should appear in. No menu items are created if this is nil.
 * CHARACTER: A unicode character to be displayed in the menu (can be
   nil if none is desired/applicable).
Note that this works with [[info:emacs#Init%20Syntax][all characters]], including "shifted"
characters like '?\C-a' or '?\M-b', if you use the correct syntax.
#+BEGIN_SRC emacs-lisp tangle: no
    (setq LaTeX-math-list '((?c "cong ")))
#+END_SRC
** Projectile Mode
Load =projectile= for project management.
#+BEGIN_SRC emacs-lisp
  (add-hook 'TeX-mode-hook #'projectile-mode)
  (add-hook 'LaTeX-mode-hook #'projectile-mode)
#+END_SRC
** ispell Mode
Note that the =ispell-tex-arg-end= function I mention below is defined
in =ispell.el= as follows.
#+BEGIN_SRC emacs-list :tangle no
  (defun ispell-tex-arg-end (&optional arg)
    "Skip across ARG number of braces."
    (condition-case nil
        (progn
          (while (looking-at "[ \t\n]*\\[") (forward-sexp))
          (forward-sexp (or arg 1)))
      (error
       (message "Error skipping s-expressions at point %d." (point))
       (beep)
       (sit-for 2))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;;; Per the documentation, `ispell-tex-skip-alists' is a list of two
  ;;; alists, each of these themselves being lists of 2- and 3-
  ;;; tuples. The tuples are all of the form
  ;;;     (BEGINREGEX ENDFUNCTION &optional BRACESCOUNT)
  ;;; where `BEGINREGEX' (the "key" referred to in this variable's
  ;;; documentation) is the regular expression (as a string) to match at
  ;;; the beginning of the region we want ispell to skip over,
  ;;; `ENDFUNCTION' is a function that moves the point forward to the
  ;;; end of the region we wish to skip. The optional argument
  ;;; `BRACESCOUNT' is a numeric argument passed to `ENDFUNCTION',
  ;;; which, for the built-in `ENDFUNCTION' (always
  ;;; `ispell-tex-arg-end') states the number of sexps to skip,
  ;;; defaulting to 1. The `ispell-tex-arg-end' function normally just
  ;;; moves past all optional arguments in the tex command, skips
  ;;; max(1,`BRACESCOUNT') matched sets of {}'s, and returns, catching
  ;;; any errors along the way. AFAICT, specifying a different value of
  ;;; `ENDFUNCTION' should just handle finding the end of the region to
  ;;; skip in a different manner without any side effects. That said,
  ;;; use at your own risk, since the source's documentation is pretty
  ;;; terrible.
  ;;;
  ;;; Actually, it looks like BOTH `BEGINREGEX' and `ENDFUNCTION' can be
  ;;; regular expressions (given as strings) and/or functions!  The
  ;;; result of each should be to move the mark to wherever you damn
  ;;; well please.
  ;;;
  ;;; The difference between the first and second entries in
  ;;; `ispell-tex-skip-alists' is that each `BEGINREGEX' inside the
  ;;; second list is matched from within a \begin{...} environment
  ;;; delimiter.  Haven't looked into how this affects the behavior of
  ;;; `ENDFUNCTION', but from the source of `ispell-tex-arg-end', the
  ;;; regexs used for `ENDFUNCTION' in the default value of
  ;;; `ispell-tex-skip-alists', and a brief read through function that
  ;;; loads the latter in `ispell.el', my guess is that `ENDFUNCTION'
  ;;; behavior is totally unaffected. (So you should look for an end
  ;;; block if you want to skip the entirety of an environment, not,
  ;;; e.g., just the environment name.)
  ;;;
  ;;; Note: `ispell-tex-arg-end' passes (or `BRACESCOUNT' 1) to
  ;;; `forward-sexp', so specifying `BRACESCOUNT' to 0 does have the
  ;;; expected effect of *only* skipping optional arguments. This is
  ;;; useful, for instance, when wanting to skip the arguments of a
  ;;; table environment (where there are never things to spellcheck),
  ;;; but you don't want to skip the table's contents.
  (setq ispell-tex-skip-alists
        (list (append (car ispell-tex-skip-alists)
                      '(("\\\\def\\\\" . ispell-tex-arg-end)))
              ;; Feel free to append to the 2nd alist, too. I've no use
              ;; for it at the moment, so it's just going back as is. Of
              ;; course, this means this whole command is rather
              ;; unnecessarily verbose for the time being. But hey, it's
              ;; readable and ready for extension.
              (cdr ispell-tex-skip-alists)))
#+END_SRC
* Appearance
** Disable Aquamacs's Auto-Face Mode
Use this to disable Aquamacs's Auto-Face Mode, which should then allow
for the use of fixed-width fonts.
#+BEGIN_SRC emacs-lisp
  (add-hook 'TeX-mode-hook 'kill-aquamacs-autoface-mode)
  (add-hook 'LaTeX-mode-hook 'kill-aquamacs-autoface-mode)
#+END_SRC
** Custom Syntax Highlighting
Syntax Highlighting is controlled by Font Lock Mode, and it is a
simple matter to add additional keywords for it to recognize and color
accordingly using the [[help:font-lock-add-keywords][font-lock-add-keywords]] function. Keywords are
passed to this function as a list of elements of the form described
[[help:font-lock-keywords][here]].

** Line Wrapping
*** Enable Soft Line Wrapping
This is achieved through Visual Line Mode and Adaptive Wrap Prefix
Mode. The former enables basic soft wrapping, and the latter indents
softly wrapped lines to the appropriate levels.

#+BEGIN_SRC emacs-lisp
  (add-hook 'visual-line-mode-hook 'adaptive-wrap-prefix-mode)
#+END_SRC

**** TODO Move this code to init.org
* TODO Improving Help Commands
Wouldn't it be amazing if there was a =describe-latex-macro= command
for Emacs with the same functionality as =describe-function=? This is
a cool idea for a project that we should totally start working on.
* Customizing Environment Templates/Insertion Behavior
** Inserting Items with Alt + Ret                           :enumerate:item:
Within enumerate-like environments (in fact, at any point in a LaTeX
buffer), hitting [Alt] + [Return] invokes [[help:LaTeX-insert-item][LaTeX-insert-item]]
* Support for Custom Macros & Environments
** Make AUCTeX Aware of Custom Theorem Environments
#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook
    (lambda ()
      (LaTeX-add-environments
        '("thm" LaTeX-env-label)
        '("lem" LaTeX-env-label)
        '("proof" LaTeX-env-label)
            '("cor" LaTeX-env-label)
            '("rem" LaTeX-env-label)
            '("claim" LaTeX-env-label))))
#+END_SRC
* Custom Functions
** TODO Forward/Backward Token/Mode/Environment Boundary Functions
By default, the key combinations 'C-M-f' and 'C-M-b' are bound to
[[help:forward-sexp][forward-sexp]] and [[help:backward-sexp][backward-sexp]], which aren't very useful in a TeX
document. We will instead bind these commands to functions that look
for the next/previous instance of a token delimiter: *{*; a math-mode
delimiter: *$*, *$$*, *\[$, or *\]$; or an environment *begin* or
*end* statement. We collectively call such things *LaTeX boundary
delimiters*, although reserve the right to change this name later.

#+SRC_NAME TeX-BoundaryDelimiters
#+BEGIN_SRC emacs-lisp :tangle no
  (defvar drmrd-init/lib/latex-TokenDelimiters
    '(("{" . nil)
      ("}" . nil))
    "An alist consisting of elements (CAR . CDR), in which CAR is
    always a string representing a (Whatever)Tex token
    delimiter. So, for instance, the default alist in a TeX or
    LaTeX distribution would include a string for matching '{' and
    another for matching '}'. In each list element, if CDR is
    non-nil treat CAR as a regular expression string and otherwise
    treat it like a string to be matched literally.")

  (defvar drmrd-init/lib/latex-MathDelimiters
    '(("$$" . nil)
      ("$" . nil)
      ("\\[" . nil)
      ("\\]" . nil))
    "An alist consisting of elements (CAR . CDR), in which CAR is
    always a string representing a (Whatever)Tex math mode
    delimiter (which is to say either an inline or displayed
    equation). So, for instance, the default alist in a TeX or
    LaTeX distribution would include strings for matching '$',
    '$$', '\[', and '\]'. In each list element, if CDR is non-nil
    treat CAR as a regular expression string and otherwise treat it
    like a string to be matched literally.")

  (defvar drmrd-init/lib/latex-EnvDelimiters
    '(("\\begin{\w+}" . t) ("\\end{\w+}" . t))
    "An alist consisting of pairs of elements (CAR . CDR), in which CAR
    is always a string representing a (Whatever)Tex environment
    beginning or ending delimiter (which is to say either an inline or
    displayed equation). So, for instance, the default alist in a LaTeX
    distribution would include strings for matching '\begin{<valid
    env-name>}' and '\end{<valid env-name>}'. In each list element, if
    CDR is non-nil treat CAR as a regular expression string and
    otherwise treat it like a string to be matched literally.")

  (defvar drmrd-init/lib/latex-BoundaryDelimiter
    (append drmrd-init/lib/latex-TokenDelimiters
            drmrd-init/lib/latex-MathDelimiters
            drmrd-init/lib/latex-EnvDelimiters)
    "The complete alist of 'LaTeX Boundary Delimiters' (delimiters
    of tokens, math modes, and environments) used, e.g., in
    conjunction with the `forward-LaTeX-boundary-delimiter'
    function. In each element (CAR . CDR), CAR is always a string
    representing a LaTeX boundary delimiter either as a string
    literal or an elisp regular expression string, with a non-nil
    CDR indicating that it is the latter.")


  (defun forward-LaTeX-boundary-delimiter (&optional arg)
    "Move forward to the next instance of a delimiter of a TeX
  token, math mode, or environment. With ARG, do it that many
  times.  Negative arg -N means find the N-th instance of such a
  delimiter in the backwards direction.  The definition of a LaTeX
  boundary delimiter may be configured by modifying the
  `drmrd-init/lib/latex-BoundaryDelimiter' variable."
    (interactive "^p") ; Recall that "^" makes this compatible with
                       ; shift selection and "p" converts the prefix
                       ; argument to a number if present.
    (or arg (setq arg 1)) ; Set `arg` equal to 1 if not provided.
    (goto-char (or (scan-latex-boundary-delimiters (point) arg) (buffer-end arg)))
    (if (< arg 0) (backward-prefix-chars)))

  (defun scan-latex-boundary-delimiters (from count)
    "Scan from character number FROM forward or backward depending
  on the sign of COUNT. Scan until |COUNT|
  LaTeX-boundary-delimiters have been found and return the
  character number of the |COUNT|-th delimiter. Returns nil if the
  beginning or end of (the accessible part of) the buffer is
  reached before |COUNT|-many matches are found."
    (sleep-for 1))
#+END_SRC


*** TODO Decide on a name for these functions
* Filling
** Disable Auto Fill Mode in LaTeX modes (for now)
I still haven't customized the fill commands for LaTeX files in a
satisfactory manner. In particular, fill still doesn't respect most
indentation, failing to indent after headers and incorrectly indenting
in most custom (and some standard) environments.

#+BEGIN_SRC emacs-lisp
  (remove-hook 'latex-mode-hook 'turn-on-auto-fill)
  (remove-hook 'LaTeX-mode-hook 'turn-on-auto-fill)
  (auto-fill-mode -1)
  ;(setq-default fill-column 99999)
  ;(setq fill-column 99999)
#+END_SRC

*** TODO Customize auto-fill more instead of disabling it.
The fill-{region, paragraph, etc.} commands for LaTeX have really
crude support for indentation built-in, to the point where this is
actually surprisingly complicated. Longterm, this definitely seems
like a worthy endeavor, though, as automatic filling would really
speed up writing, e.g., large lists. Part of this might also be
implemented "softly" using soft word wrap.
** Fill Sentences (Instead of Paragraphs)
The following function is due to Luca de Alfaro, and it allows you to
fill individual sentences instead of full paragraphs. This is useful
if you intend to keep sentences on separate lines.

- Note: This command still breaks sentences onto multiple lines for
  some aggravating reason. I need to fix how filling works.

This command is bound to "M-j".

#+BEGIN_SRC emacs-lisp
  (defun fill-sentence ()
    "Fill an individual sentence instead of a paragraph."
    (interactive)
    (save-excursion
      (or (eq (point) (point-max)) (forward-char))
      (forward-sentence -1)
      (indent-relative)
      (let ((beg (point)))
        (forward-sentence)
        (fill-region-as-paragraph beg (point)))))

  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (define-key LaTeX-mode-map
                          (kbd "M-j")
                          'fill-sentence)))
#+END_SRC
** Advise fill-region to start each sentence on a new line
#+BEGIN_SRC emacs-lisp
  (defadvice LaTeX-fill-region-as-paragraph (around LaTeX-sentence-filling)
    "Start each sentence on a new line."
    (let ((from (ad-get-arg 0))
          (to-marker (set-marker (make-marker) (ad-get-arg 1)))
          tmp-end)
      (while (< from (marker-position to-marker))
        (forward-sentence)
        ;; might have gone beyond to-marker --- use whichever is smaller:
        (ad-set-arg 1 (setq tmp-end (min (point) (marker-position to-marker))))
        ad-do-it
        (ad-set-arg 0 (setq from (point)))
        (unless (or
                 (bolp)
                 (looking-at "\\s *$"))
          (LaTeX-newline)))
      (set-marker to-marker nil)))
  (ad-activate 'LaTeX-fill-region-as-paragraph)
#+END_SRC
* Indentation
** Set default indentation level to 4 spaces
#+BEGIN_SRC emacs-lisp
  (setq-default LaTeX-default-offset 4)
#+END_SRC
** Customize general indentation settings
#+BEGIN_SRC emacs-lisp
  ;;
  ;; Customizing general indentation settings
  ;;
  ; Set indentation of current line by 4n where n is the sum of the
  ; number of unmatched instances of "\begin{<environment>}" and "{":
  (setq-default LaTeX-indent-level 4)
  (setq-default TeX-brace-indent-level 4)
  ; Add 0m to indentation level of current line where m is the number
  ; currently-unmatched, enumerate-like environments at our current
  ; location (and the cursor is on a line beginning with "\item" or
  ; something "\item-like":
  (setq-default LaTeX-item-indent 0)
#+END_SRC
** Advise indent command to indent inside parts, chapters, sections, etc.
#+BEGIN_SRC emacs-lisp
  (defadvice LaTeX-indent-line (after LaTeX-indent-line-in-sections-advice activate)
    "A function designed to advise the indent command to indent within
     parts, chapters, sections, subsections, etc."
    (interactive)
    (let (
           (section-list ; Make a copy of LaTeX-section-headers
             (copy-list LaTeX-section-list)
           )
           (prevline ; Set equal to the previous line as a string
             (save-excursion
               (forward-line -1)
               (thing-at-point 'line t)
             )
           )
         )
         ; If the previous line is the start of a section, indent
         ; the current line by an additional LaTeX-default-offset
         ; spaces.
         ;
         ; The while loop essentially uses section-list, a copy of
         ; LaTeX-section-list, as a stack, pushing another section
         ; name off the stack with each iteration until it is empty.
         ;
         ; The entire while loop is wrapped in a save-excursion call
         ; to avoid moving the pointer around. I'm not sure if this
         ; is less efficient than just putting it in the conditional
         ; or if it matters at all. Perhaps something to look into
         ; another time.
         (save-excursion
           (while section-list
             (if (string-match (concat "\s-+\\" (caar section-list) ".*\s-") prevline)
               (progn
                 ; Move to first non-whitespace character in line
                 (back-to-indentation)
                 ; Insert LaTeX-default-offset many spaces
                 (indent-to 0 LaTeX-default-offset)
                 (setq section-list nil)
               )
             )
             (setq section-list (cdr section-list))
           )
         )
    )
  )
#+END_SRC
*** DONE Fix the interaction between this and environment insertion commands
CLOSED: [2015-12-05 Sat 14:27]
It seems that this advice may break environment insertion via C-c
C-e. The latter now places the "\end{...}" block immediately before
the "\begin{...}" one.
*** I've officially learned a trick or two!
Figuring out the "right" way to implement this in Emacs was daunting a
few months ago. Today (<2015-12-02 Wed>) I did it in 1.5 hours.
* Spell Checking
** Enable Flyspell Mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook 'flyspell-mode)
#+END_SRC
* Debugging
** Change TeX debugging mode (for more informative error messages)
#+BEGIN_SRC emacs-lisp
  (setq LaTeX-command-style '(("" "%(PDF)%(latex) -file-line-error %S%(PDFout)")))
#+END_SRC
* Compilation & External Programs
** Compile PDFs by Default
#+BEGIN_SRC emacs-lisp
  (setq TeX-PDF-mode t)
#+END_SRC
** Create Custom Compilation Commands (& Tweak Built-In Ones)
#+BEGIN_SRC emacs-lisp
    (defun drmrd/latex/string=-cars (cons1 cons2)
      "Determine if two cons are equal by comparing their cars as
      strings. The car comparison is done using `string='. No
      type-checking is performed before attempting to compare cons, so
      this can lead to unexpected outcomes if CONS1 and CONS2 are not
      lists (or if their cars are not strings)."
      (string= (car cons1) (car cons2)))
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook
    (lambda ()
      (add-to-list 'TeX-command-list
                   '("latexmk" "latexmk -outdir=./tmp %t -pdf %s"
                     TeX-run-TeX nil t :help "Run latexmk on file")
                   nil 'drmrd/latex/string=-cars)))
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (add-hook 'LaTeX-mode-hook
    (lambda ()
      (add-to-list 'TeX-command-list
                   '("LaTeX+" "latexmk -auxdir=./tmp %t -pdf %s"
                     TeX-run-TeX nil t :help
                     "Run latexmk, storing temporary files in ./tmp")
                     nil 'drmrd/latex/string=-cars)))
#+END_SRC
** Enable support for latexmk via C-c C-c
#+BEGIN_SRC emacs-lisp

  ;(add-hook 'TeX-mode-hook '(lambda () (setq TeX-command-default "latexmk")))
#+END_SRC
** Set how TeX handles DVI files
#+BEGIN_SRC emacs-lisp
  (setq tex-dvi-print-command "dvips")
  (setq tex-dvi-view-command "xdvi")
#+END_SRC
** Store temporary files in ./tmp

* Wrap Up
There is nothing to do here for the time being, but we'll at least
record that we've loaded the file successfully in the *Messages* buffer.
#+BEGIN_SRC emacs-lisp
  (message "Finished loading LaTeX configuration!")
#+END_SRC
